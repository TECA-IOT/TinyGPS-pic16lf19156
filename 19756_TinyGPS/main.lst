CCS PCM C Compiler, Version 5.093, 43599               22-Feb-21 12:47

               Filename:   C:\Users\panda\Desktop\pics\19756_serial\main.lst

               ROM used:   3766 words (23%)
                           Largest free fragment is 2048
               RAM used:   1262 (62%) at main() level
                           1311 (64%) worst case
               Stack used: 3 locations
               Stack size: 16

0000:  MOVLP  08
0001:  GOTO   480
0002:  NOP
.................... 
.................... #include <main.h>
.................... #include <16LF19156.h>
.................... //////////// Standard Header file for the PIC16LF19156 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16LF19156
0003:  DATA C2,27
0004:  DATA 4F,2A
0005:  DATA A0,10
0006:  DATA A0,06
0007:  DATA 8A,06
0008:  DATA 8A,06
0009:  DATA 0A,00
000A:  DATA CC,30
000B:  DATA 3A,10
000C:  DATA 25,17
000D:  DATA 36,33
000E:  DATA 20,26
000F:  DATA 6F,1D
0010:  DATA A0,12
0011:  DATA 2E,1B
0012:  DATA 66,10
0013:  DATA F3,30
0014:  DATA 74,1D
0015:  DATA A0,12
0016:  DATA 64,10
0017:  DATA 68,32
0018:  DATA 6F,38
0019:  DATA 3A,10
001A:  DATA 25,36
001B:  DATA E4,06
001C:  DATA 0A,00
*
0026:  MOVF   0B,W
0027:  BCF    0B.7
0028:  MOVLB  10
0029:  BSF    1E.7
002A:  BSF    1E.0
002B:  NOP
002C:  NOP
002D:  BTFSC  09.7
002E:  BSF    0B.7
002F:  MOVF   1C,W
0030:  ANDLW  7F
0031:  BTFSC  03.2
0032:  GOTO   072
0033:  MOVLB  0F
0034:  MOVWF  52
0035:  MOVLB  10
0036:  MOVF   1A,W
0037:  MOVLB  0F
0038:  MOVWF  53
0039:  MOVLB  10
003A:  MOVF   1B,W
003B:  MOVLB  0F
003C:  MOVWF  54
003D:  MOVF   52,W
003E:  MOVWF  60
003F:  MOVLB  00
0040:  CALL   01D
0041:  MOVLB  0F
0042:  MOVF   53,W
0043:  MOVLB  10
0044:  MOVWF  1A
0045:  MOVLB  0F
0046:  MOVF   54,W
0047:  MOVLB  10
0048:  MOVWF  1B
0049:  MOVF   0B,W
004A:  BCF    0B.7
004B:  BSF    1E.7
004C:  BSF    1E.0
004D:  NOP
004E:  NOP
004F:  BTFSC  09.7
0050:  BSF    0B.7
0051:  RLF    1C,W
0052:  RLF    1D,W
0053:  ANDLW  7F
0054:  BTFSC  03.2
0055:  GOTO   072
0056:  MOVLB  0F
0057:  MOVWF  52
0058:  MOVLB  10
0059:  MOVF   1A,W
005A:  MOVLB  0F
005B:  MOVWF  53
005C:  MOVLB  10
005D:  MOVF   1B,W
005E:  MOVLB  0F
005F:  MOVWF  54
0060:  MOVF   52,W
0061:  MOVWF  60
0062:  MOVLB  00
0063:  CALL   01D
0064:  MOVLB  0F
0065:  MOVF   53,W
0066:  MOVLB  10
0067:  MOVWF  1A
0068:  MOVLB  0F
0069:  MOVF   54,W
006A:  MOVLB  10
006B:  MOVWF  1B
006C:  INCF   1A,F
006D:  BTFSC  03.2
006E:  INCF   1B,F
006F:  MOVLB  00
0070:  GOTO   026
0071:  MOVLB  10
0072:  MOVLP  08
0073:  MOVLB  00
0074:  GOTO   50F (RETURN)
*
0100:  MOVLW  20
0101:  MOVLB  10
0102:  MOVWF  2E
0103:  CLRF   2A
0104:  CLRF   2B
0105:  CLRF   2C
0106:  CLRF   2D
0107:  MOVF   23,W
0108:  MOVWF  7A
0109:  MOVF   22,W
010A:  MOVWF  79
010B:  MOVF   21,W
010C:  MOVWF  78
010D:  MOVF   20,W
010E:  MOVWF  77
010F:  BCF    03.0
0110:  BTFSS  77.0
0111:  GOTO   120
0112:  MOVF   24,W
0113:  ADDWF  2A,F
0114:  MOVF   25,W
0115:  BTFSC  03.0
0116:  INCFSZ 25,W
0117:  ADDWF  2B,F
0118:  MOVF   26,W
0119:  BTFSC  03.0
011A:  INCFSZ 26,W
011B:  ADDWF  2C,F
011C:  MOVF   27,W
011D:  BTFSC  03.0
011E:  INCFSZ 27,W
011F:  ADDWF  2D,F
0120:  RRF    2D,F
0121:  RRF    2C,F
0122:  RRF    2B,F
0123:  RRF    2A,F
0124:  RRF    7A,F
0125:  RRF    79,F
0126:  RRF    78,F
0127:  RRF    77,F
0128:  DECFSZ 2E,F
0129:  GOTO   10F
012A:  MOVLB  00
012B:  RETURN
*
0188:  CLRF   77
0189:  CLRF   78
018A:  MOVLB  0F
018B:  MOVF   5F,W
018C:  BCF    03.0
018D:  BTFSC  60.0
018E:  ADDWF  77,F
018F:  RRF    77,F
0190:  RRF    78,F
0191:  BTFSC  60.1
0192:  ADDWF  77,F
0193:  RRF    77,F
0194:  RRF    78,F
0195:  BTFSC  60.2
0196:  ADDWF  77,F
0197:  RRF    77,F
0198:  RRF    78,F
0199:  BTFSC  60.3
019A:  ADDWF  77,F
019B:  RRF    77,F
019C:  RRF    78,F
019D:  BTFSC  60.4
019E:  ADDWF  77,F
019F:  RRF    77,F
01A0:  RRF    78,F
01A1:  BTFSC  60.5
01A2:  ADDWF  77,F
01A3:  RRF    77,F
01A4:  RRF    78,F
01A5:  BTFSC  60.6
01A6:  ADDWF  77,F
01A7:  RRF    77,F
01A8:  RRF    78,F
01A9:  BTFSC  60.7
01AA:  ADDWF  77,F
01AB:  RRF    77,F
01AC:  RRF    78,F
01AD:  MOVLB  00
01AE:  RETURN
*
027E:  BTFSC  03.1
027F:  GOTO   284
0280:  MOVLW  25
0281:  MOVWF  05
0282:  MOVLW  05
0283:  MOVWF  04
0284:  CLRF   77
0285:  CLRF   78
0286:  CLRF   79
0287:  CLRF   7A
0288:  MOVLB  10
0289:  CLRF   25
028A:  CLRF   26
028B:  CLRF   27
028C:  CLRF   28
028D:  MOVF   23,W
028E:  IORWF  22,W
028F:  IORWF  21,W
0290:  IORWF  20,W
0291:  BTFSC  03.2
0292:  GOTO   2C5
0293:  MOVLW  20
0294:  MOVWF  29
0295:  BCF    03.0
0296:  MOVLB  0F
0297:  RLF    6C,F
0298:  RLF    6D,F
0299:  RLF    6E,F
029A:  RLF    6F,F
029B:  MOVLB  10
029C:  RLF    25,F
029D:  RLF    26,F
029E:  RLF    27,F
029F:  RLF    28,F
02A0:  MOVF   23,W
02A1:  SUBWF  28,W
02A2:  BTFSS  03.2
02A3:  GOTO   2AE
02A4:  MOVF   22,W
02A5:  SUBWF  27,W
02A6:  BTFSS  03.2
02A7:  GOTO   2AE
02A8:  MOVF   21,W
02A9:  SUBWF  26,W
02AA:  BTFSS  03.2
02AB:  GOTO   2AE
02AC:  MOVF   20,W
02AD:  SUBWF  25,W
02AE:  BTFSS  03.0
02AF:  GOTO   2BF
02B0:  MOVF   20,W
02B1:  SUBWF  25,F
02B2:  MOVF   21,W
02B3:  BTFSS  03.0
02B4:  INCFSZ 21,W
02B5:  SUBWF  26,F
02B6:  MOVF   22,W
02B7:  BTFSS  03.0
02B8:  INCFSZ 22,W
02B9:  SUBWF  27,F
02BA:  MOVF   23,W
02BB:  BTFSS  03.0
02BC:  INCFSZ 23,W
02BD:  SUBWF  28,F
02BE:  BSF    03.0
02BF:  RLF    77,F
02C0:  RLF    78,F
02C1:  RLF    79,F
02C2:  RLF    7A,F
02C3:  DECFSZ 29,F
02C4:  GOTO   295
02C5:  MOVF   25,W
02C6:  MOVWF  00
02C7:  MOVF   26,W
02C8:  MOVWI  W,[FSR0+01]
02C9:  MOVF   27,W
02CA:  MOVWI  W,[FSR0+02]
02CB:  MOVF   28,W
02CC:  MOVWI  W,[FSR0+03]
02CD:  MOVLB  00
02CE:  RETURN
*
06A3:  BCF    0A.0
06A4:  BSF    0A.1
06A5:  BSF    0A.2
06A6:  ADDWF  02,F
06A7:  GOTO   510
06A8:  GOTO   52B
06A9:  GOTO   53F
06AA:  GOTO   552
06AB:  GOTO   55D
06AC:  GOTO   597
06AD:  GOTO   59E
06AE:  GOTO   687
06AF:  GOTO   692
06B0:  GOTO   69D
06B1:  GOTO   69D
06B2:  GOTO   69D
06B3:  GOTO   69D
06B4:  GOTO   69D
06B5:  GOTO   69D
06B6:  GOTO   69D
06B7:  GOTO   69D
06B8:  GOTO   69D
06B9:  GOTO   69D
06BA:  GOTO   69D
06BB:  GOTO   69D
06BC:  GOTO   69D
06BD:  GOTO   69D
06BE:  GOTO   69D
06BF:  GOTO   69D
06C0:  GOTO   69D
06C1:  GOTO   69D
06C2:  GOTO   69D
06C3:  GOTO   69D
06C4:  GOTO   69D
06C5:  GOTO   69D
06C6:  GOTO   69D
06C7:  GOTO   510
06C8:  GOTO   524
06C9:  GOTO   52B
06CA:  GOTO   53F
06CB:  GOTO   552
06CC:  GOTO   55D
06CD:  GOTO   570
06CE:  GOTO   57B
06CF:  GOTO   586
*
0735:  MOVLW  B6
0736:  MOVWF  77
0737:  CLRF   7A
0738:  CLRF   79
0739:  CLRF   78
073A:  MOVLB  0F
073B:  MOVF   60,W
073C:  IORWF  61,W
073D:  IORWF  62,W
073E:  IORWF  63,W
073F:  BTFSS  03.2
0740:  GOTO   743
0741:  CLRF   77
0742:  GOTO   750
0743:  BCF    03.0
0744:  BTFSC  78.7
0745:  GOTO   74F
0746:  RLF    60,F
0747:  RLF    61,F
0748:  RLF    62,F
0749:  RLF    63,F
074A:  RLF    7A,F
074B:  RLF    79,F
074C:  RLF    78,F
074D:  DECFSZ 77,F
074E:  GOTO   743
074F:  BCF    78.7
0750:  MOVLB  00
0751:  RETURN
0752:  MOVLB  0F
0753:  MOVF   51,W
0754:  MOVWF  58
0755:  MOVF   55,W
0756:  XORWF  58,F
0757:  BTFSS  58.7
0758:  GOTO   75E
0759:  BCF    03.2
075A:  BCF    03.0
075B:  BTFSC  51.7
075C:  BSF    03.0
075D:  GOTO   791
075E:  MOVF   51,W
075F:  MOVWF  58
0760:  MOVF   54,W
0761:  MOVWF  59
0762:  MOVF   50,W
0763:  SUBWF  59,F
0764:  BTFSC  03.2
0765:  GOTO   76C
0766:  BTFSS  58.7
0767:  GOTO   791
0768:  MOVF   03,W
0769:  XORLW  01
076A:  MOVWF  03
076B:  GOTO   791
076C:  MOVF   55,W
076D:  MOVWF  59
076E:  MOVF   51,W
076F:  SUBWF  59,F
0770:  BTFSC  03.2
0771:  GOTO   778
0772:  BTFSS  58.7
0773:  GOTO   791
0774:  MOVF   03,W
0775:  XORLW  01
0776:  MOVWF  03
0777:  GOTO   791
0778:  MOVF   56,W
0779:  MOVWF  59
077A:  MOVF   52,W
077B:  SUBWF  59,F
077C:  BTFSC  03.2
077D:  GOTO   784
077E:  BTFSS  58.7
077F:  GOTO   791
0780:  MOVF   03,W
0781:  XORLW  01
0782:  MOVWF  03
0783:  GOTO   791
0784:  MOVF   57,W
0785:  MOVWF  59
0786:  MOVF   53,W
0787:  SUBWF  59,F
0788:  BTFSC  03.2
0789:  GOTO   790
078A:  BTFSS  58.7
078B:  GOTO   791
078C:  MOVF   03,W
078D:  XORLW  01
078E:  MOVWF  03
078F:  GOTO   791
0790:  BCF    03.0
0791:  MOVLB  00
0792:  RETURN
0793:  MOVF   0B,W
0794:  BCF    0B.7
0795:  MOVLB  10
0796:  BSF    1E.7
0797:  BSF    1E.0
0798:  NOP
0799:  NOP
079A:  BTFSC  09.7
079B:  BSF    0B.7
079C:  BTFSC  03.0
079D:  GOTO   7C6
079E:  MOVF   1C,W
079F:  ANDLW  7F
07A0:  MOVLB  0F
07A1:  MOVWF  52
07A2:  MOVLB  10
07A3:  MOVF   1A,W
07A4:  MOVLB  0F
07A5:  MOVWF  53
07A6:  MOVLB  10
07A7:  MOVF   1B,W
07A8:  MOVLB  0F
07A9:  MOVWF  54
07AA:  MOVF   52,W
07AB:  MOVWF  60
07AC:  MOVLB  00
07AD:  CALL   01D
07AE:  MOVLB  0F
07AF:  MOVF   53,W
07B0:  MOVLB  10
07B1:  MOVWF  1A
07B2:  MOVLB  0F
07B3:  MOVF   54,W
07B4:  MOVLB  10
07B5:  MOVWF  1B
07B6:  MOVF   0B,W
07B7:  BCF    0B.7
07B8:  BSF    1E.7
07B9:  BSF    1E.0
07BA:  NOP
07BB:  NOP
07BC:  BTFSC  09.7
07BD:  BSF    0B.7
07BE:  MOVLB  0F
07BF:  DECFSZ 50,F
07C0:  GOTO   7C2
07C1:  GOTO   7C4
07C2:  MOVLB  10
07C3:  GOTO   7C6
07C4:  GOTO   7E9
07C5:  MOVLB  10
07C6:  RLF    1C,W
07C7:  RLF    1D,W
07C8:  ANDLW  7F
07C9:  MOVLB  0F
07CA:  MOVWF  52
07CB:  MOVLB  10
07CC:  MOVF   1A,W
07CD:  MOVLB  0F
07CE:  MOVWF  53
07CF:  MOVLB  10
07D0:  MOVF   1B,W
07D1:  MOVLB  0F
07D2:  MOVWF  54
07D3:  MOVF   52,W
07D4:  MOVWF  60
07D5:  MOVLB  00
07D6:  CALL   01D
07D7:  MOVLB  0F
07D8:  MOVF   53,W
07D9:  MOVLB  10
07DA:  MOVWF  1A
07DB:  MOVLB  0F
07DC:  MOVF   54,W
07DD:  MOVLB  10
07DE:  MOVWF  1B
07DF:  INCF   1A,F
07E0:  BTFSC  03.2
07E1:  INCF   1B,F
07E2:  BCF    03.0
07E3:  MOVLB  0F
07E4:  DECFSZ 50,F
07E5:  GOTO   7E7
07E6:  GOTO   7E9
07E7:  MOVLB  00
07E8:  GOTO   793
07E9:  MOVLB  00
07EA:  RETURN
*
0800:  MOVLB  0F
0801:  MOVF   60,W
0802:  BTFSC  03.2
0803:  GOTO   0C7
0804:  MOVWF  6E
0805:  MOVF   64,W
0806:  BTFSC  03.2
0807:  GOTO   0C7
0808:  SUBWF  6E,F
0809:  BTFSC  03.0
080A:  GOTO   00C
080B:  GOTO   011
080C:  MOVLW  7F
080D:  ADDWF  6E,F
080E:  BTFSC  03.0
080F:  GOTO   0C7
0810:  GOTO   017
0811:  MOVLW  81
0812:  SUBWF  6E,F
0813:  BTFSS  03.0
0814:  GOTO   0C7
0815:  BTFSC  03.2
0816:  GOTO   0C7
0817:  MOVF   6E,W
0818:  MOVWF  77
0819:  CLRF   78
081A:  CLRF   79
081B:  CLRF   7A
081C:  CLRF   6D
081D:  MOVF   61,W
081E:  MOVWF  6C
081F:  BSF    6C.7
0820:  MOVF   62,W
0821:  MOVWF  6B
0822:  MOVF   63,W
0823:  MOVWF  6A
0824:  MOVLW  19
0825:  MOVWF  6E
0826:  MOVF   67,W
0827:  SUBWF  6A,F
0828:  BTFSC  03.0
0829:  GOTO   03A
082A:  MOVLW  01
082B:  SUBWF  6B,F
082C:  BTFSC  03.0
082D:  GOTO   03A
082E:  SUBWF  6C,F
082F:  BTFSC  03.0
0830:  GOTO   03A
0831:  SUBWF  6D,F
0832:  BTFSC  03.0
0833:  GOTO   03A
0834:  INCF   6D,F
0835:  INCF   6C,F
0836:  INCF   6B,F
0837:  MOVF   67,W
0838:  ADDWF  6A,F
0839:  GOTO   06C
083A:  MOVF   66,W
083B:  SUBWF  6B,F
083C:  BTFSC  03.0
083D:  GOTO   055
083E:  MOVLW  01
083F:  SUBWF  6C,F
0840:  BTFSC  03.0
0841:  GOTO   055
0842:  SUBWF  6D,F
0843:  BTFSC  03.0
0844:  GOTO   055
0845:  INCF   6D,F
0846:  INCF   6C,F
0847:  MOVF   66,W
0848:  ADDWF  6B,F
0849:  MOVF   67,W
084A:  ADDWF  6A,F
084B:  BTFSS  03.0
084C:  GOTO   06C
084D:  INCF   6B,F
084E:  BTFSS  03.2
084F:  GOTO   06C
0850:  INCF   6C,F
0851:  BTFSS  03.2
0852:  GOTO   06C
0853:  INCF   6D,F
0854:  GOTO   06C
0855:  MOVF   65,W
0856:  IORLW  80
0857:  SUBWF  6C,F
0858:  BTFSC  03.0
0859:  GOTO   06B
085A:  MOVLW  01
085B:  SUBWF  6D,F
085C:  BTFSC  03.0
085D:  GOTO   06B
085E:  INCF   6D,F
085F:  MOVF   65,W
0860:  IORLW  80
0861:  ADDWF  6C,F
0862:  MOVF   66,W
0863:  ADDWF  6B,F
0864:  BTFSS  03.0
0865:  GOTO   049
0866:  INCF   6C,F
0867:  BTFSS  03.2
0868:  GOTO   049
0869:  INCF   6D,F
086A:  GOTO   049
086B:  BSF    7A.0
086C:  DECFSZ 6E,F
086D:  GOTO   06F
086E:  GOTO   07A
086F:  BCF    03.0
0870:  RLF    6A,F
0871:  RLF    6B,F
0872:  RLF    6C,F
0873:  RLF    6D,F
0874:  BCF    03.0
0875:  RLF    7A,F
0876:  RLF    79,F
0877:  RLF    78,F
0878:  RLF    6F,F
0879:  GOTO   026
087A:  BTFSS  6F.0
087B:  GOTO   082
087C:  BCF    03.0
087D:  RRF    78,F
087E:  RRF    79,F
087F:  RRF    7A,F
0880:  RRF    6F,F
0881:  GOTO   085
0882:  DECF   77,F
0883:  BTFSC  03.2
0884:  GOTO   0C7
0885:  BTFSC  6F.7
0886:  GOTO   0AE
0887:  BCF    03.0
0888:  RLF    6A,F
0889:  RLF    6B,F
088A:  RLF    6C,F
088B:  RLF    6D,F
088C:  MOVF   67,W
088D:  SUBWF  6A,F
088E:  BTFSC  03.0
088F:  GOTO   09A
0890:  MOVLW  01
0891:  SUBWF  6B,F
0892:  BTFSC  03.0
0893:  GOTO   09A
0894:  SUBWF  6C,F
0895:  BTFSC  03.0
0896:  GOTO   09A
0897:  SUBWF  6D,F
0898:  BTFSS  03.0
0899:  GOTO   0BD
089A:  MOVF   66,W
089B:  SUBWF  6B,F
089C:  BTFSC  03.0
089D:  GOTO   0A5
089E:  MOVLW  01
089F:  SUBWF  6C,F
08A0:  BTFSC  03.0
08A1:  GOTO   0A5
08A2:  SUBWF  6D,F
08A3:  BTFSS  03.0
08A4:  GOTO   0BD
08A5:  MOVF   65,W
08A6:  IORLW  80
08A7:  SUBWF  6C,F
08A8:  BTFSC  03.0
08A9:  GOTO   0AE
08AA:  MOVLW  01
08AB:  SUBWF  6D,F
08AC:  BTFSS  03.0
08AD:  GOTO   0BD
08AE:  INCF   7A,F
08AF:  BTFSS  03.2
08B0:  GOTO   0BD
08B1:  INCF   79,F
08B2:  BTFSS  03.2
08B3:  GOTO   0BD
08B4:  INCF   78,F
08B5:  BTFSS  03.2
08B6:  GOTO   0BD
08B7:  INCF   77,F
08B8:  BTFSC  03.2
08B9:  GOTO   0C7
08BA:  RRF    78,F
08BB:  RRF    79,F
08BC:  RRF    7A,F
08BD:  MOVF   61,W
08BE:  MOVWF  6E
08BF:  MOVF   65,W
08C0:  XORWF  6E,F
08C1:  BTFSS  6E.7
08C2:  GOTO   0C5
08C3:  BSF    78.7
08C4:  GOTO   0CB
08C5:  BCF    78.7
08C6:  GOTO   0CB
08C7:  CLRF   77
08C8:  CLRF   78
08C9:  CLRF   79
08CA:  CLRF   7A
08CB:  MOVLB  00
08CC:  RETURN
*
09E1:  MOVF   04,W
09E2:  MOVLB  0F
09E3:  MOVWF  58
09E4:  MOVF   54,W
09E5:  MOVWF  5A
09E6:  BTFSC  03.2
09E7:  GOTO   274
09E8:  MOVF   53,W
09E9:  MOVWF  63
09EA:  MOVF   52,W
09EB:  MOVWF  62
09EC:  MOVF   51,W
09ED:  MOVWF  61
09EE:  MOVF   50,W
09EF:  MOVWF  60
09F0:  CLRF   67
09F1:  CLRF   66
09F2:  MOVLW  20
09F3:  MOVWF  65
09F4:  MOVLW  82
09F5:  MOVWF  64
09F6:  MOVF   60,W
09F7:  BTFSC  03.2
09F8:  GOTO   266
09F9:  MOVWF  6B
09FA:  MOVF   64,W
09FB:  BTFSC  03.2
09FC:  GOTO   266
09FD:  ADDWF  6B,F
09FE:  BTFSC  03.0
09FF:  GOTO   207
0A00:  MOVLW  7F
0A01:  SUBWF  6B,F
0A02:  BTFSS  03.0
0A03:  GOTO   266
0A04:  BTFSC  03.2
0A05:  GOTO   266
0A06:  GOTO   20B
0A07:  MOVLW  81
0A08:  ADDWF  6B,F
0A09:  BTFSC  03.0
0A0A:  GOTO   266
0A0B:  MOVF   6B,W
0A0C:  MOVWF  77
0A0D:  CLRF   78
0A0E:  CLRF   79
0A0F:  CLRF   7A
0A10:  MOVF   61,W
0A11:  MOVWF  6F
0A12:  BSF    6F.7
0A13:  MOVF   62,W
0A14:  MOVWF  6E
0A15:  MOVF   63,W
0A16:  MOVWF  6D
0A17:  MOVLW  18
0A18:  MOVWF  6B
0A19:  CLRF   6C
0A1A:  BTFSS  6D.0
0A1B:  GOTO   234
0A1C:  MOVF   67,W
0A1D:  ADDWF  7A,F
0A1E:  BTFSS  03.0
0A1F:  GOTO   226
0A20:  INCF   79,F
0A21:  BTFSS  03.2
0A22:  GOTO   226
0A23:  INCF   78,F
0A24:  BTFSC  03.2
0A25:  BSF    6C.7
0A26:  MOVF   66,W
0A27:  ADDWF  79,F
0A28:  BTFSS  03.0
0A29:  GOTO   22D
0A2A:  INCF   78,F
0A2B:  BTFSC  03.2
0A2C:  BSF    6C.7
0A2D:  MOVF   65,W
0A2E:  MOVWF  62
0A2F:  BSF    62.7
0A30:  MOVF   62,W
0A31:  ADDWF  78,F
0A32:  BTFSC  03.0
0A33:  BSF    6C.7
0A34:  RLF    6C,F
0A35:  RRF    78,F
0A36:  RRF    79,F
0A37:  RRF    7A,F
0A38:  RRF    6F,F
0A39:  RRF    6E,F
0A3A:  RRF    6D,F
0A3B:  BCF    03.0
0A3C:  DECFSZ 6B,F
0A3D:  GOTO   219
0A3E:  MOVLW  01
0A3F:  ADDWF  77,F
0A40:  BTFSC  03.0
0A41:  GOTO   266
0A42:  BTFSC  78.7
0A43:  GOTO   24B
0A44:  RLF    6F,F
0A45:  RLF    7A,F
0A46:  RLF    79,F
0A47:  RLF    78,F
0A48:  DECF   77,F
0A49:  BTFSC  03.2
0A4A:  GOTO   266
0A4B:  BTFSS  6F.7
0A4C:  GOTO   25C
0A4D:  INCF   7A,F
0A4E:  BTFSS  03.2
0A4F:  GOTO   25C
0A50:  INCF   79,F
0A51:  BTFSS  03.2
0A52:  GOTO   25C
0A53:  INCF   78,F
0A54:  BTFSS  03.2
0A55:  GOTO   25C
0A56:  RRF    78,F
0A57:  RRF    79,F
0A58:  RRF    7A,F
0A59:  INCF   77,F
0A5A:  BTFSC  03.2
0A5B:  GOTO   266
0A5C:  MOVF   61,W
0A5D:  MOVWF  6C
0A5E:  MOVF   65,W
0A5F:  XORWF  6C,F
0A60:  BTFSS  6C.7
0A61:  GOTO   264
0A62:  BSF    78.7
0A63:  GOTO   26A
0A64:  BCF    78.7
0A65:  GOTO   26A
0A66:  CLRF   77
0A67:  CLRF   78
0A68:  CLRF   79
0A69:  CLRF   7A
0A6A:  MOVF   7A,W
0A6B:  MOVWF  53
0A6C:  MOVF   79,W
0A6D:  MOVWF  52
0A6E:  MOVF   78,W
0A6F:  MOVWF  51
0A70:  MOVF   77,W
0A71:  MOVWF  50
0A72:  DECFSZ 5A,F
0A73:  GOTO   1E8
0A74:  MOVF   53,W
0A75:  MOVWF  63
0A76:  MOVF   52,W
0A77:  MOVWF  62
0A78:  MOVF   51,W
0A79:  MOVWF  61
0A7A:  MOVF   50,W
0A7B:  MOVWF  60
0A7C:  MOVF   60,W
0A7D:  SUBLW  B6
0A7E:  MOVWF  60
0A7F:  CLRF   7A
0A80:  MOVF   61,W
0A81:  MOVWF  64
0A82:  BSF    61.7
0A83:  BCF    03.0
0A84:  RRF    61,F
0A85:  RRF    62,F
0A86:  RRF    63,F
0A87:  RRF    7A,F
0A88:  RRF    79,F
0A89:  RRF    78,F
0A8A:  RRF    77,F
0A8B:  DECFSZ 60,F
0A8C:  GOTO   283
0A8D:  BTFSS  64.7
0A8E:  GOTO   29A
0A8F:  COMF   77,F
0A90:  COMF   78,F
0A91:  COMF   79,F
0A92:  COMF   7A,F
0A93:  INCF   77,F
0A94:  BTFSC  03.2
0A95:  INCF   78,F
0A96:  BTFSC  03.2
0A97:  INCF   79,F
0A98:  BTFSC  03.2
0A99:  INCF   7A,F
0A9A:  MOVF   7A,W
0A9B:  MOVWF  53
0A9C:  MOVF   79,W
0A9D:  MOVWF  52
0A9E:  MOVF   78,W
0A9F:  MOVWF  51
0AA0:  MOVF   77,W
0AA1:  MOVWF  50
0AA2:  BTFSS  53.7
0AA3:  GOTO   2B1
0AA4:  DECF   58,F
0AA5:  BSF    58.5
0AA6:  COMF   50,F
0AA7:  COMF   51,F
0AA8:  COMF   52,F
0AA9:  COMF   53,F
0AAA:  INCF   50,F
0AAB:  BTFSC  03.2
0AAC:  INCF   51,F
0AAD:  BTFSC  03.2
0AAE:  INCF   52,F
0AAF:  BTFSC  03.2
0AB0:  INCF   53,F
0AB1:  MOVLW  3B
0AB2:  MOVWF  5F
0AB3:  MOVLW  9A
0AB4:  MOVWF  5E
0AB5:  MOVLW  CA
0AB6:  MOVWF  5D
0AB7:  CLRF   5C
0AB8:  MOVLW  0A
0AB9:  MOVWF  5A
0ABA:  MOVF   54,W
0ABB:  BTFSC  03.2
0ABC:  INCF   58,F
0ABD:  BSF    03.1
0ABE:  MOVLW  24
0ABF:  MOVWF  05
0AC0:  MOVLW  E0
0AC1:  MOVWF  04
0AC2:  MOVF   53,W
0AC3:  MOVWF  6F
0AC4:  MOVF   52,W
0AC5:  MOVWF  6E
0AC6:  MOVF   51,W
0AC7:  MOVWF  6D
0AC8:  MOVF   50,W
0AC9:  MOVWF  6C
0ACA:  MOVF   5F,W
0ACB:  MOVLB  10
0ACC:  MOVWF  23
0ACD:  MOVLB  0F
0ACE:  MOVF   5E,W
0ACF:  MOVLB  10
0AD0:  MOVWF  22
0AD1:  MOVLB  0F
0AD2:  MOVF   5D,W
0AD3:  MOVLB  10
0AD4:  MOVWF  21
0AD5:  MOVLB  0F
0AD6:  MOVF   5C,W
0AD7:  MOVLB  10
0AD8:  MOVWF  20
0AD9:  MOVLP  00
0ADA:  MOVLB  00
0ADB:  CALL   27E
0ADC:  MOVLP  08
0ADD:  MOVF   78,W
0ADE:  MOVF   77,F
0ADF:  BTFSS  03.2
0AE0:  GOTO   2F8
0AE1:  MOVLB  0F
0AE2:  INCF   54,W
0AE3:  SUBWF  5A,W
0AE4:  BTFSS  03.2
0AE5:  GOTO   2E8
0AE6:  MOVLB  00
0AE7:  GOTO   2F8
0AE8:  MOVF   58,W
0AE9:  BTFSC  03.2
0AEA:  GOTO   2FB
0AEB:  ANDLW  0F
0AEC:  SUBWF  5A,W
0AED:  BTFSC  03.2
0AEE:  GOTO   2F1
0AEF:  BTFSC  03.0
0AF0:  GOTO   33B
0AF1:  BTFSC  58.7
0AF2:  GOTO   33B
0AF3:  BTFSC  58.6
0AF4:  GOTO   2FB
0AF5:  MOVLW  20
0AF6:  GOTO   333
0AF7:  MOVLB  00
0AF8:  MOVLW  20
0AF9:  MOVLB  0F
0AFA:  ANDWF  58,F
0AFB:  BTFSS  58.5
0AFC:  GOTO   30D
0AFD:  BCF    58.5
0AFE:  MOVF   54,W
0AFF:  BTFSS  03.2
0B00:  DECF   58,F
0B01:  MOVF   77,W
0B02:  MOVWF  58
0B03:  MOVLW  2D
0B04:  MOVWF  60
0B05:  MOVLP  00
0B06:  MOVLB  00
0B07:  CALL   01D
0B08:  MOVLP  08
0B09:  MOVLB  0F
0B0A:  MOVF   58,W
0B0B:  MOVWF  77
0B0C:  CLRF   58
0B0D:  MOVF   54,W
0B0E:  SUBWF  5A,W
0B0F:  BTFSS  03.2
0B10:  GOTO   31F
0B11:  MOVF   77,W
0B12:  MOVWF  58
0B13:  MOVLW  2E
0B14:  MOVWF  60
0B15:  MOVLP  00
0B16:  MOVLB  00
0B17:  CALL   01D
0B18:  MOVLP  08
0B19:  MOVLB  0F
0B1A:  MOVF   58,W
0B1B:  MOVWF  77
0B1C:  MOVLW  20
0B1D:  ANDWF  58,F
0B1E:  MOVLW  00
0B1F:  MOVLW  30
0B20:  BTFSS  58.5
0B21:  GOTO   333
0B22:  BCF    58.5
0B23:  MOVF   54,W
0B24:  BTFSS  03.2
0B25:  DECF   58,F
0B26:  MOVF   77,W
0B27:  MOVWF  58
0B28:  MOVLW  2D
0B29:  MOVWF  60
0B2A:  MOVLP  00
0B2B:  MOVLB  00
0B2C:  CALL   01D
0B2D:  MOVLP  08
0B2E:  MOVLB  0F
0B2F:  MOVF   58,W
0B30:  MOVWF  77
0B31:  CLRF   58
0B32:  MOVLW  30
0B33:  ADDWF  77,F
0B34:  MOVF   77,W
0B35:  MOVWF  60
0B36:  MOVLP  00
0B37:  MOVLB  00
0B38:  CALL   01D
0B39:  MOVLP  08
0B3A:  MOVLB  0F
0B3B:  BCF    03.1
0B3C:  MOVF   5F,W
0B3D:  MOVWF  6F
0B3E:  MOVF   5E,W
0B3F:  MOVWF  6E
0B40:  MOVF   5D,W
0B41:  MOVWF  6D
0B42:  MOVF   5C,W
0B43:  MOVWF  6C
0B44:  MOVLB  10
0B45:  CLRF   23
0B46:  CLRF   22
0B47:  CLRF   21
0B48:  MOVLW  0A
0B49:  MOVWF  20
0B4A:  MOVLP  00
0B4B:  MOVLB  00
0B4C:  CALL   27E
0B4D:  MOVLP  08
0B4E:  MOVF   7A,W
0B4F:  MOVLB  0F
0B50:  MOVWF  5F
0B51:  MOVF   79,W
0B52:  MOVWF  5E
0B53:  MOVF   78,W
0B54:  MOVWF  5D
0B55:  MOVF   77,W
0B56:  MOVWF  5C
0B57:  DECFSZ 5A,F
0B58:  GOTO   2BD
0B59:  MOVLB  00
0B5A:  RETURN
0B5B:  MOVLB  0F
0B5C:  MOVF   59,W
0B5D:  CLRF   78
0B5E:  SUBWF  58,W
0B5F:  BTFSC  03.0
0B60:  GOTO   364
0B61:  MOVF   58,W
0B62:  MOVWF  77
0B63:  GOTO   370
0B64:  CLRF   77
0B65:  MOVLW  08
0B66:  MOVWF  5A
0B67:  RLF    58,F
0B68:  RLF    77,F
0B69:  MOVF   59,W
0B6A:  SUBWF  77,W
0B6B:  BTFSC  03.0
0B6C:  MOVWF  77
0B6D:  RLF    78,F
0B6E:  DECFSZ 5A,F
0B6F:  GOTO   367
0B70:  MOVLB  00
0B71:  RETURN
0B72:  MOVLW  20
0B73:  MOVLB  0F
0B74:  BTFSS  51.4
0B75:  MOVLW  30
0B76:  MOVWF  54
0B77:  MOVF   50,W
0B78:  MOVWF  77
0B79:  BTFSS  50.7
0B7A:  GOTO   383
0B7B:  COMF   77,F
0B7C:  INCF   77,F
0B7D:  MOVF   77,W
0B7E:  MOVWF  50
0B7F:  MOVLW  2D
0B80:  MOVWF  54
0B81:  BSF    51.7
0B82:  BSF    51.0
0B83:  MOVF   50,W
0B84:  MOVWF  58
0B85:  MOVLW  64
0B86:  MOVWF  59
0B87:  MOVLB  00
0B88:  CALL   35B
0B89:  MOVF   77,W
0B8A:  MOVLB  0F
0B8B:  MOVWF  50
0B8C:  MOVLW  30
0B8D:  ADDWF  78,W
0B8E:  MOVWF  55
0B8F:  MOVF   50,W
0B90:  MOVWF  58
0B91:  MOVLW  0A
0B92:  MOVWF  59
0B93:  MOVLB  00
0B94:  CALL   35B
0B95:  MOVLW  30
0B96:  ADDWF  77,W
0B97:  MOVLB  0F
0B98:  MOVWF  57
0B99:  MOVLW  30
0B9A:  ADDWF  78,W
0B9B:  MOVWF  56
0B9C:  MOVF   54,W
0B9D:  MOVWF  77
0B9E:  MOVLW  30
0B9F:  SUBWF  55,W
0BA0:  BTFSC  03.2
0BA1:  GOTO   3A6
0BA2:  BSF    51.1
0BA3:  BTFSC  51.7
0BA4:  BSF    51.2
0BA5:  GOTO   3BA
0BA6:  MOVF   54,W
0BA7:  MOVWF  55
0BA8:  MOVLW  20
0BA9:  MOVWF  54
0BAA:  MOVLW  30
0BAB:  SUBWF  56,W
0BAC:  BTFSC  03.2
0BAD:  GOTO   3B2
0BAE:  BSF    51.0
0BAF:  BTFSC  51.7
0BB0:  BSF    51.1
0BB1:  GOTO   3BA
0BB2:  BTFSS  03.2
0BB3:  BSF    51.0
0BB4:  BTFSS  03.2
0BB5:  GOTO   3BA
0BB6:  MOVF   55,W
0BB7:  MOVWF  56
0BB8:  MOVLW  20
0BB9:  MOVWF  55
0BBA:  BTFSC  51.2
0BBB:  GOTO   3C1
0BBC:  BTFSC  51.1
0BBD:  GOTO   3C8
0BBE:  BTFSC  51.0
0BBF:  GOTO   3CF
0BC0:  GOTO   3D6
0BC1:  MOVF   54,W
0BC2:  MOVWF  60
0BC3:  MOVLP  00
0BC4:  MOVLB  00
0BC5:  CALL   01D
0BC6:  MOVLP  08
0BC7:  MOVLB  0F
0BC8:  MOVF   55,W
0BC9:  MOVWF  60
0BCA:  MOVLP  00
0BCB:  MOVLB  00
0BCC:  CALL   01D
0BCD:  MOVLP  08
0BCE:  MOVLB  0F
0BCF:  MOVF   56,W
0BD0:  MOVWF  60
0BD1:  MOVLP  00
0BD2:  MOVLB  00
0BD3:  CALL   01D
0BD4:  MOVLP  08
0BD5:  MOVLB  0F
0BD6:  MOVF   57,W
0BD7:  MOVWF  60
0BD8:  MOVLP  00
0BD9:  MOVLB  00
0BDA:  CALL   01D
0BDB:  MOVLP  08
0BDC:  MOVLP  08
0BDD:  GOTO   69B (RETURN)
0BDE:  MOVF   04,W
0BDF:  MOVLB  0F
0BE0:  MOVWF  58
0BE1:  BTFSS  53.7
0BE2:  GOTO   3F0
0BE3:  DECF   58,F
0BE4:  BSF    58.5
0BE5:  COMF   50,F
0BE6:  COMF   51,F
0BE7:  COMF   52,F
0BE8:  COMF   53,F
0BE9:  INCF   50,F
0BEA:  BTFSC  03.2
0BEB:  INCF   51,F
0BEC:  BTFSC  03.2
0BED:  INCF   52,F
0BEE:  BTFSC  03.2
0BEF:  INCF   53,F
0BF0:  MOVLW  3B
0BF1:  MOVWF  5F
0BF2:  MOVLW  9A
0BF3:  MOVWF  5E
0BF4:  MOVLW  CA
0BF5:  MOVWF  5D
0BF6:  CLRF   5C
0BF7:  MOVLW  0A
0BF8:  MOVWF  5A
0BF9:  BSF    03.1
0BFA:  MOVLW  24
0BFB:  MOVWF  05
0BFC:  MOVLW  E0
0BFD:  MOVWF  04
0BFE:  MOVF   53,W
0BFF:  MOVWF  6F
0C00:  MOVF   52,W
0C01:  MOVWF  6E
0C02:  MOVF   51,W
0C03:  MOVWF  6D
0C04:  MOVF   50,W
0C05:  MOVWF  6C
0C06:  MOVF   5F,W
0C07:  MOVLB  10
0C08:  MOVWF  23
0C09:  MOVLB  0F
0C0A:  MOVF   5E,W
0C0B:  MOVLB  10
0C0C:  MOVWF  22
0C0D:  MOVLB  0F
0C0E:  MOVF   5D,W
0C0F:  MOVLB  10
0C10:  MOVWF  21
0C11:  MOVLB  0F
0C12:  MOVF   5C,W
0C13:  MOVLB  10
0C14:  MOVWF  20
0C15:  MOVLP  00
0C16:  MOVLB  00
0C17:  CALL   27E
0C18:  MOVLP  08
0C19:  MOVF   78,W
0C1A:  MOVF   77,F
0C1B:  BTFSS  03.2
0C1C:  GOTO   434
0C1D:  MOVLB  0F
0C1E:  MOVF   5A,W
0C1F:  XORLW  01
0C20:  BTFSS  03.2
0C21:  GOTO   424
0C22:  MOVLB  00
0C23:  GOTO   434
0C24:  MOVF   58,W
0C25:  BTFSC  03.2
0C26:  GOTO   437
0C27:  ANDLW  0F
0C28:  SUBWF  5A,W
0C29:  BTFSC  03.2
0C2A:  GOTO   42D
0C2B:  BTFSC  03.0
0C2C:  GOTO   45F
0C2D:  BTFSC  58.7
0C2E:  GOTO   45F
0C2F:  BTFSC  58.6
0C30:  GOTO   437
0C31:  MOVLW  20
0C32:  GOTO   457
0C33:  MOVLB  00
0C34:  MOVLW  20
0C35:  MOVLB  0F
0C36:  ANDWF  58,F
0C37:  BTFSS  58.5
0C38:  GOTO   446
0C39:  BCF    58.5
0C3A:  MOVF   77,W
0C3B:  MOVWF  58
0C3C:  MOVLW  2D
0C3D:  MOVWF  60
0C3E:  MOVLP  00
0C3F:  MOVLB  00
0C40:  CALL   01D
0C41:  MOVLP  08
0C42:  MOVLB  0F
0C43:  MOVF   58,W
0C44:  MOVWF  77
0C45:  CLRF   58
0C46:  MOVLW  30
0C47:  BTFSS  58.5
0C48:  GOTO   457
0C49:  BCF    58.5
0C4A:  MOVF   77,W
0C4B:  MOVWF  58
0C4C:  MOVLW  2D
0C4D:  MOVWF  60
0C4E:  MOVLP  00
0C4F:  MOVLB  00
0C50:  CALL   01D
0C51:  MOVLP  08
0C52:  MOVLB  0F
0C53:  MOVF   58,W
0C54:  MOVWF  77
0C55:  CLRF   58
0C56:  MOVLW  30
0C57:  ADDWF  77,F
0C58:  MOVF   77,W
0C59:  MOVWF  60
0C5A:  MOVLP  00
0C5B:  MOVLB  00
0C5C:  CALL   01D
0C5D:  MOVLP  08
0C5E:  MOVLB  0F
0C5F:  BCF    03.1
0C60:  MOVF   5F,W
0C61:  MOVWF  6F
0C62:  MOVF   5E,W
0C63:  MOVWF  6E
0C64:  MOVF   5D,W
0C65:  MOVWF  6D
0C66:  MOVF   5C,W
0C67:  MOVWF  6C
0C68:  MOVLB  10
0C69:  CLRF   23
0C6A:  CLRF   22
0C6B:  CLRF   21
0C6C:  MOVLW  0A
0C6D:  MOVWF  20
0C6E:  MOVLP  00
0C6F:  MOVLB  00
0C70:  CALL   27E
0C71:  MOVLP  08
0C72:  MOVF   7A,W
0C73:  MOVLB  0F
0C74:  MOVWF  5F
0C75:  MOVF   79,W
0C76:  MOVWF  5E
0C77:  MOVF   78,W
0C78:  MOVWF  5D
0C79:  MOVF   77,W
0C7A:  MOVWF  5C
0C7B:  DECFSZ 5A,F
0C7C:  GOTO   3F9
0C7D:  MOVLP  08
0C7E:  MOVLB  00
0C7F:  GOTO   6B5 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=12
.................... #fuses NOCLKOUT, NOLCDPEN, MCLR, PUT_64MS, NOLPBOR, NOBROWNOUT, NOZCDDIS,STVREN, NODEBUG, NOWDT, LVP
.................... //#use delay(internal=16000000)
.................... #use delay(internal=1000000)
*
0075:  MOVLW  24
0076:  MOVWF  05
0077:  MOVLW  E1
0078:  MOVWF  04
0079:  MOVF   00,W
007A:  BTFSC  03.2
007B:  GOTO   082
007C:  MOVLW  52
007D:  MOVWF  77
007E:  DECFSZ 77,F
007F:  GOTO   07E
0080:  DECFSZ 00,F
0081:  GOTO   07C
0082:  RETURN
.................... 
.................... 
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ublox)
.................... #use rs232(DISABLE_INTS,baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ublox)
*
001D:  MOVLB  0E
001E:  BTFSS  0F.4
001F:  GOTO   01E
0020:  MOVLB  0F
0021:  MOVF   60,W
0022:  MOVLB  02
0023:  MOVWF  1A
0024:  MOVLB  00
0025:  RETURN
*
0083:  MOVLB  0E
0084:  BTFSS  0F.5
0085:  GOTO   084
0086:  MOVLB  02
0087:  MOVF   1D,W
0088:  MOVLB  00
0089:  MOVWF  20
008A:  MOVLB  02
008B:  MOVF   19,W
008C:  MOVWF  78
008D:  MOVLB  00
008E:  BTFSS  20.1
008F:  GOTO   094
0090:  MOVLB  02
0091:  BCF    1D.4
0092:  BSF    1D.4
0093:  MOVLB  00
0094:  MOVLP  08
0095:  GOTO   563 (RETURN)
.................... 
.................... #include <tinyGPS.h>
.................... /*
.................... TinyGPS - a small GPS library for Arduino providing basic NMEA parsing
.................... Based on work by and "distance_to" and "course_to" courtesy of Maarten Lamers.
.................... Suggestion to add satellites(), course_to(), and cardinal(), by Matt Monson.
.................... Precision improvements suggested by Wayne Holder.
.................... Copyright (C) 2008-2013 Mikal Hart
.................... All rights reserved.
.................... 
.................... This library is free software; you can redistribute it and/or
.................... modify it under the terms of the GNU Lesser General Public
.................... License as published by the Free Software Foundation; either
.................... version 2.1 of the License, or (at your option) any later version.
.................... 
.................... This library is distributed in the hope that it will be useful,
.................... but WITHOUT ANY WARRANTY; without even the implied warranty of
.................... MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.................... Lesser General Public License for more details.
.................... 
.................... You should have received a copy of the GNU Lesser General Public
.................... License aint32 with this library; if not, write to the Free Software
.................... Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
.................... */
.................... 
.................... #ifndef TinyGPS_h
.................... #define TinyGPS_h
.................... 
.................... int32 segundos_ABS = 0;
.................... 
.................... //#if defined(ARDUINO) && ARDUINO >= 100
.................... //#include "Arduino.h"
.................... //#else
.................... //#include "WProgram.h"
.................... //#endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
*
05A3:  CLRF   5B
....................    sign = 0;
05A4:  CLRF   59
....................    base = 10;
05A5:  MOVLW  0A
05A6:  MOVWF  5A
....................    result = 0;
05A7:  CLRF   58
.................... 
....................    if (!s)
05A8:  MOVF   56,W
05A9:  IORWF  57,W
05AA:  BTFSS  03.2
05AB:  GOTO   5AF
....................       return 0;
05AC:  MOVLW  00
05AD:  MOVWF  78
05AE:  GOTO   681
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
05AF:  MOVF   5B,W
05B0:  INCF   5B,F
05B1:  ADDWF  56,W
05B2:  MOVWF  04
05B3:  MOVLW  00
05B4:  ADDWFC 57,W
05B5:  MOVWF  05
05B6:  MOVF   00,W
05B7:  MOVWF  5C
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
05B8:  MOVF   5C,W
05B9:  SUBLW  2D
05BA:  BTFSS  03.2
05BB:  GOTO   5C8
....................    {
....................       sign = 1;         // Set the sign to negative
05BC:  MOVLW  01
05BD:  MOVWF  59
....................       c = s[index++];
05BE:  MOVF   5B,W
05BF:  INCF   5B,F
05C0:  ADDWF  56,W
05C1:  MOVWF  04
05C2:  MOVLW  00
05C3:  ADDWFC 57,W
05C4:  MOVWF  05
05C5:  MOVF   00,W
05C6:  MOVWF  5C
....................    }
05C7:  GOTO   5D5
....................    else if (c == '+')
05C8:  MOVF   5C,W
05C9:  SUBLW  2B
05CA:  BTFSS  03.2
05CB:  GOTO   5D5
....................    {
....................       c = s[index++];
05CC:  MOVF   5B,W
05CD:  INCF   5B,F
05CE:  ADDWF  56,W
05CF:  MOVWF  04
05D0:  MOVLW  00
05D1:  ADDWFC 57,W
05D2:  MOVWF  05
05D3:  MOVF   00,W
05D4:  MOVWF  5C
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
05D5:  MOVF   5C,W
05D6:  SUBLW  2F
05D7:  BTFSC  03.0
05D8:  GOTO   677
05D9:  MOVF   5C,W
05DA:  SUBLW  39
05DB:  BTFSS  03.0
05DC:  GOTO   677
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
05DD:  MOVF   5C,W
05DE:  SUBLW  30
05DF:  BTFSS  03.2
05E0:  GOTO   601
05E1:  MOVF   5B,W
05E2:  ADDWF  56,W
05E3:  MOVWF  04
05E4:  MOVLW  00
05E5:  ADDWFC 57,W
05E6:  MOVWF  05
05E7:  MOVF   00,W
05E8:  SUBLW  78
05E9:  BTFSC  03.2
05EA:  GOTO   5F5
05EB:  MOVF   5B,W
05EC:  ADDWF  56,W
05ED:  MOVWF  04
05EE:  MOVLW  00
05EF:  ADDWFC 57,W
05F0:  MOVWF  05
05F1:  MOVF   00,W
05F2:  SUBLW  58
05F3:  BTFSS  03.2
05F4:  GOTO   601
....................       {
....................          base = 16;
05F5:  MOVLW  10
05F6:  MOVWF  5A
....................          index++;
05F7:  INCF   5B,F
....................          c = s[index++];
05F8:  MOVF   5B,W
05F9:  INCF   5B,F
05FA:  ADDWF  56,W
05FB:  MOVWF  04
05FC:  MOVLW  00
05FD:  ADDWFC 57,W
05FE:  MOVWF  05
05FF:  MOVF   00,W
0600:  MOVWF  5C
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
0601:  MOVF   5A,W
0602:  SUBLW  0A
0603:  BTFSS  03.2
0604:  GOTO   625
....................       {
....................          while (c >= '0' && c <= '9')
0605:  MOVF   5C,W
0606:  SUBLW  2F
0607:  BTFSC  03.0
0608:  GOTO   624
0609:  MOVF   5C,W
060A:  SUBLW  39
060B:  BTFSS  03.0
060C:  GOTO   624
....................          {
....................             result = 10*result + (c - '0');
060D:  MOVLW  0A
060E:  MOVWF  5F
060F:  MOVF   58,W
0610:  MOVWF  60
0611:  MOVLB  00
0612:  CALL   188
0613:  MOVF   78,W
0614:  MOVLB  0F
0615:  MOVWF  5E
0616:  MOVLW  30
0617:  SUBWF  5C,W
0618:  ADDWF  5E,W
0619:  MOVWF  58
....................             c = s[index++];
061A:  MOVF   5B,W
061B:  INCF   5B,F
061C:  ADDWF  56,W
061D:  MOVWF  04
061E:  MOVLW  00
061F:  ADDWFC 57,W
0620:  MOVWF  05
0621:  MOVF   00,W
0622:  MOVWF  5C
0623:  GOTO   605
....................          }
....................       }
0624:  GOTO   677
....................       else if (base == 16)    // The number is a hexa number
0625:  MOVF   5A,W
0626:  SUBLW  10
0627:  BTFSS  03.2
0628:  GOTO   677
....................       {
....................          c = toupper(c);
0629:  MOVF   5C,W
062A:  SUBLW  60
062B:  BTFSC  03.0
062C:  GOTO   634
062D:  MOVF   5C,W
062E:  SUBLW  7A
062F:  BTFSS  03.0
0630:  GOTO   634
0631:  MOVF   5C,W
0632:  ANDLW  DF
0633:  GOTO   635
0634:  MOVF   5C,W
0635:  MOVWF  5C
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
0636:  MOVF   5C,W
0637:  SUBLW  2F
0638:  BTFSC  03.0
0639:  GOTO   63E
063A:  MOVF   5C,W
063B:  SUBLW  39
063C:  BTFSC  03.0
063D:  GOTO   646
063E:  MOVF   5C,W
063F:  SUBLW  40
0640:  BTFSC  03.0
0641:  GOTO   677
0642:  MOVF   5C,W
0643:  SUBLW  46
0644:  BTFSS  03.0
0645:  GOTO   677
....................          {
....................             if (c >= '0' && c <= '9')
0646:  MOVF   5C,W
0647:  SUBLW  2F
0648:  BTFSC  03.0
0649:  GOTO   657
064A:  MOVF   5C,W
064B:  SUBLW  39
064C:  BTFSS  03.0
064D:  GOTO   657
....................                result = (result << 4) + (c - '0');
064E:  SWAPF  58,W
064F:  MOVWF  5E
0650:  MOVLW  F0
0651:  ANDWF  5E,F
0652:  MOVLW  30
0653:  SUBWF  5C,W
0654:  ADDWF  5E,W
0655:  MOVWF  58
0656:  GOTO   660
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
0657:  SWAPF  58,W
0658:  MOVWF  5E
0659:  MOVLW  F0
065A:  ANDWF  5E,F
065B:  MOVLW  41
065C:  SUBWF  5C,W
065D:  ADDLW  0A
065E:  ADDWF  5E,W
065F:  MOVWF  58
.................... 
....................             c = s[index++];
0660:  MOVF   5B,W
0661:  INCF   5B,F
0662:  ADDWF  56,W
0663:  MOVWF  04
0664:  MOVLW  00
0665:  ADDWFC 57,W
0666:  MOVWF  05
0667:  MOVF   00,W
0668:  MOVWF  5C
....................             c = toupper(c);
0669:  MOVF   5C,W
066A:  SUBLW  60
066B:  BTFSC  03.0
066C:  GOTO   674
066D:  MOVF   5C,W
066E:  SUBLW  7A
066F:  BTFSS  03.0
0670:  GOTO   674
0671:  MOVF   5C,W
0672:  ANDLW  DF
0673:  GOTO   675
0674:  MOVF   5C,W
0675:  MOVWF  5C
0676:  GOTO   636
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
0677:  DECFSZ 59,W
0678:  GOTO   67F
0679:  MOVF   5A,W
067A:  SUBLW  0A
067B:  BTFSS  03.2
067C:  GOTO   67F
....................        result = -result;
067D:  COMF   58,F
067E:  INCF   58,F
.................... 
....................    return(result);
067F:  MOVF   58,W
0680:  MOVWF  78
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #define _GPS_VERSION 13 // software version of this library
.................... #define _GPS_MPH_PER_KNOT 1.15077945
.................... #define _GPS_MPS_PER_KNOT 0.51444444
.................... #define _GPS_KMPH_PER_KNOT 1.852
.................... #define _GPS_MILES_PER_METER 0.00062137112
.................... #define _GPS_KM_PER_METER 0.001
.................... #define _GPS_NO_STATS//////////////////////////////////////////////7
.................... 
.................... //class TinyGPS
.................... //{
.................... //public:
....................   enum {
....................     GPS_INVALID_AGE = 0xFFFFFFFF,      GPS_INVALID_ANGLE = 999999999, 
....................     GPS_INVALID_ALTITUDE = 999999999,  GPS_INVALID_DATE = 0,
....................     GPS_INVALID_TIME = 0xFFFFFFFF,       GPS_INVALID_SPEED = 999999999, 
....................     GPS_INVALID_FIX_TIME = 0xFFFFFFFF, GPS_INVALID_SATELLITES = 0xFF,
....................     GPS_INVALID_HDOP = 0xFFFFFFFF
....................   };
....................   
.................... 
.................... //private:
....................   enum {_GPS_SENTENCE_GPGGA, _GPS_SENTENCE_GPRMC, _GPS_SENTENCE_OTHER};
.................... 
....................   // properties
....................   unsigned int32 _time, _new_time;
....................   unsigned int32 _date, _new_date;
....................   int32 _latitude, _new_latitude;
....................   int32 _longitude, _new_longitude;
....................   int32 _altitude, _new_altitude;
....................   unsigned int32  _speed, _new_speed;
....................   unsigned int32  _course, _new_course;
....................   unsigned int32  _hdop, _new_hdop;
....................   int16 _numsats, _new_numsats;
.................... 
....................   unsigned int32 _last_time_fix, _new_time_fix;
....................   unsigned int32 _last_position_fix, _new_position_fix;
.................... 
....................   // parsing state variables
....................   byte _parity;
....................   boolean _is_checksum_term;
....................   char _term[15];
....................   byte _sentence_type;
....................   byte _term_number;
....................   byte _term_offset;
....................   boolean _gps_data_good;
.................... 
....................   static const float GPS_INVALID_F_ANGLE = 1000.0;
....................   static const float GPS_INVALID_F_ALTITUDE = 1000000.0;
....................   static const float GPS_INVALID_F_SPEED = -1.0;
....................   //const 
.................... //float TinyGPS::GPS_INVALID_F_ANGLE = 1000.0;
.................... //const 
.................... //float TinyGPS::GPS_INVALID_F_ALTITUDE = 1000000.0;
.................... //const 
.................... //float TinyGPS::GPS_INVALID_F_SPEED = -1.0;
.................... 
....................   //TinyGPS();
....................   void tinyGPS_init();
....................   boolean encode(char c); // process one character received from GPS
....................   //TinyGPS &operator << (char c) {encode(c); return *this;}
.................... 
....................   // lat/int32 in MILLIONTHs of a degree and age of fix in milliseconds
....................   // (note: versions 12 and earlier gave lat/int32 in 100,000ths of a degree.
....................   void get_position(int32 *latitude, int32 *longitude, unsigned int32 *fix_age = 0);
.................... 
....................   // date as ddmmyy, time as hhmmsscc, and age in milliseconds
....................   void get_datetime(unsigned int32 *date, unsigned int32 *time, unsigned int32 *age = 0);
.................... 
....................   // signed altitude in centimeters (from GPGGA sentence)
....................   inline int32 altitude() { return _altitude; }
.................... 
....................   // course in last full GPRMC sentence in 100th of a degree
....................   inline unsigned int32 course() { return _course; }
.................... 
....................   // speed in last full GPRMC sentence in 100ths of a knot
....................   inline unsigned int32 speed() { return _speed; }
.................... 
....................   // satellites used in last full GPGGA sentence
....................   inline unsigned short satellites() { return _numsats; }
*
0DB4:  MOVF   6B,W
0DB5:  MOVWF  78
*
0E1D:  MOVF   6B,W
0E1E:  MOVWF  78
.................... 
....................   // horizontal dilution of precision in 100ths
....................   inline unsigned int32 hdop() { return _hdop; }
*
0DB9:  MOVLB  00
0DBA:  MOVF   63,W
0DBB:  MOVWF  77
0DBC:  MOVF   64,W
0DBD:  MOVWF  78
0DBE:  MOVF   65,W
0DBF:  MOVWF  79
0DC0:  MOVF   66,W
0DC1:  MOVWF  7A
*
0E24:  MOVF   63,W
0E25:  MOVWF  77
0E26:  MOVF   64,W
0E27:  MOVWF  78
0E28:  MOVF   65,W
0E29:  MOVWF  79
0E2A:  MOVF   66,W
0E2B:  MOVWF  7A
.................... 
....................   void f_get_position(float *latitude, float *longitude, unsigned int32 *fix_age = 0);
....................   void crack_datetime(int16 *year, byte *month, byte *day, 
....................     byte *hour, byte *minute, byte *second, byte *hundredths = 0, unsigned int32 *fix_age = 0);
....................   float f_altitude();
....................   float f_course();
....................   float f_speed_knots();
....................   float f_speed_mph();
....................   float f_speed_mps();
....................   float f_speed_kmph();
.................... 
....................   static int16 library_version() { return _GPS_VERSION; }
.................... 
....................   static float distance_between (float lat1, float long1, float lat2, float long2);
....................   static float course_to (float lat1, float long1, float lat2, float long2);
....................   static const char *cardinal(float course);
.................... 
.................... #ifndef _GPS_NO_STATS
....................   void stats(unsigned int32 *chars, unsigned short *good_sentences, unsigned short *failed_cs);
.................... #endif
.................... 
.................... 
.................... #ifndef _GPS_NO_STATS
....................   // statistics
....................   unsigned int32 _encoded_characters;
....................   unsigned short _good_sentences;
....................   unsigned short _failed_checksum;
....................   unsigned short _passed_checksum;
.................... #endif
.................... 
....................   // internal utilities
....................   int16 from_hex(char a);
....................   unsigned int32 parse_decimal();
....................   unsigned int32 parse_degrees();
....................   boolean term_complete();
....................   boolean gpsisdigit(char c) { return c >= '0' && c <= '9'; }
*
00F1:  MOVLB  0F
00F2:  MOVF   6D,W
00F3:  SUBLW  2F
00F4:  BTFSC  03.0
00F5:  GOTO   0FA
00F6:  MOVF   6D,W
00F7:  SUBLW  39
00F8:  BTFSC  03.0
00F9:  GOTO   0FC
00FA:  MOVLW  00
00FB:  GOTO   0FD
00FC:  MOVLW  01
00FD:  MOVWF  78
00FE:  MOVLB  00
00FF:  RETURN
....................   int32 gpsatol(char *str);
....................   int16 gpsstrcmp(char *str1, char *str2);
....................   
.................... //};
.................... 
.................... //!#if !defined(ARDUINO) 
.................... //!// Arduino 0012 workaround
.................... //!#undef int
.................... //!#undef char
.................... //!#undef long
.................... //!#undef byte
.................... //!#undef float
.................... //!#undef abs
.................... //!#undef round 
.................... //!#endif
.................... //!
.................... //!#endif
.................... 
.................... 
.................... //#include <tinyGPS.c>
.................... 
.................... 
.................... //#define _GPRMC_TERM   "GPRMC"
.................... char _GPRMC_TERM[] =   "GPRMC";
.................... //#define _GPGGA_TERM   "GPGGA"
.................... char _GPGGA_TERM[] = "GPGGA";
.................... 
.................... int32 millis(){return segundos_ABS*1000;}
*
0266:  MOVF   24,W
0267:  MOVLB  10
0268:  MOVWF  23
0269:  MOVLB  00
026A:  MOVF   23,W
026B:  MOVLB  10
026C:  MOVWF  22
026D:  MOVLB  00
026E:  MOVF   22,W
026F:  MOVLB  10
0270:  MOVWF  21
0271:  MOVLB  00
0272:  MOVF   21,W
0273:  MOVLB  10
0274:  MOVWF  20
0275:  CLRF   27
0276:  CLRF   26
0277:  MOVLW  03
0278:  MOVWF  25
0279:  MOVLW  E8
027A:  MOVWF  24
027B:  MOVLB  00
027C:  CALL   100
027D:  RETURN
.................... 
.................... #define COMBINE(sentence_type, term_number) (((unsigned)(sentence_type) << 5) | term_number)
.................... 
.................... 
.................... void get_position(int32 *latitude, int32 *longitude, unsigned int32 *fix_age)
.................... {
....................   if (latitude) *latitude = _latitude;
*
08DA:  MOVF   5E,W
08DB:  IORWF  5F,W
08DC:  BTFSC  03.2
08DD:  GOTO   0F2
08DE:  MOVF   5F,W
08DF:  MOVWF  7A
08E0:  MOVF   5E,W
08E1:  MOVWF  04
08E2:  MOVF   5F,W
08E3:  MOVWF  05
08E4:  MOVLB  00
08E5:  MOVF   3B,W
08E6:  MOVWF  00
08E7:  ADDFSR 01,FSR0
08E8:  MOVF   3C,W
08E9:  MOVWF  00
08EA:  ADDFSR 01,FSR0
08EB:  MOVF   3D,W
08EC:  MOVWF  00
08ED:  ADDFSR 01,FSR0
08EE:  MOVF   3E,W
08EF:  MOVWF  00
08F0:  ADDFSR 3D,FSR0
08F1:  MOVLB  0F
....................   if (longitude) *longitude = _longitude;
08F2:  MOVF   60,W
08F3:  IORWF  61,W
08F4:  BTFSC  03.2
08F5:  GOTO   10A
08F6:  MOVF   61,W
08F7:  MOVWF  7A
08F8:  MOVF   60,W
08F9:  MOVWF  04
08FA:  MOVF   61,W
08FB:  MOVWF  05
08FC:  MOVLB  00
08FD:  MOVF   43,W
08FE:  MOVWF  00
08FF:  ADDFSR 01,FSR0
0900:  MOVF   44,W
0901:  MOVWF  00
0902:  ADDFSR 01,FSR0
0903:  MOVF   45,W
0904:  MOVWF  00
0905:  ADDFSR 01,FSR0
0906:  MOVF   46,W
0907:  MOVWF  00
0908:  ADDFSR 3D,FSR0
0909:  MOVLB  0F
....................   if (fix_age) *fix_age = _last_position_fix == GPS_INVALID_FIX_TIME ? 
090A:  MOVF   62,W
090B:  IORWF  63,W
090C:  BTFSC  03.2
090D:  GOTO   15A
....................    GPS_INVALID_AGE : millis() - _last_position_fix;
090E:  MOVF   63,W
090F:  MOVWF  7A
0910:  MOVF   62,W
0911:  MOVWF  64
0912:  MOVF   63,W
0913:  MOVWF  65
0914:  MOVLB  01
0915:  INCFSZ 28,W
0916:  GOTO   123
0917:  INCFSZ 29,W
0918:  GOTO   123
0919:  INCFSZ 2A,W
091A:  GOTO   123
091B:  INCFSZ 2B,W
091C:  GOTO   123
091D:  MOVLW  FF
091E:  MOVWF  77
091F:  MOVWF  78
0920:  MOVWF  79
0921:  MOVWF  7A
0922:  GOTO   145
0923:  MOVLP  00
0924:  MOVLB  00
0925:  CALL   266
0926:  MOVLP  08
0927:  MOVF   7A,W
0928:  MOVLB  0F
0929:  MOVWF  69
092A:  MOVF   79,W
092B:  MOVWF  68
092C:  MOVF   78,W
092D:  MOVWF  67
092E:  MOVF   77,W
092F:  MOVWF  66
0930:  MOVLB  01
0931:  MOVF   28,W
0932:  MOVLB  0F
0933:  SUBWF  66,W
0934:  MOVWF  77
0935:  MOVLB  01
0936:  MOVF   29,W
0937:  MOVLB  0F
0938:  SUBWFC 67,W
0939:  MOVWF  78
093A:  MOVLB  01
093B:  MOVF   2A,W
093C:  MOVLB  0F
093D:  SUBWFC 68,W
093E:  MOVWF  79
093F:  MOVLB  01
0940:  MOVF   2B,W
0941:  MOVLB  0F
0942:  SUBWFC 69,W
0943:  MOVWF  7A
0944:  MOVLB  01
0945:  MOVF   7A,W
0946:  MOVLB  0F
0947:  MOVWF  69
0948:  MOVF   79,W
0949:  MOVWF  68
094A:  MOVF   78,W
094B:  MOVWF  67
094C:  MOVF   77,W
094D:  MOVWF  66
094E:  MOVF   65,W
094F:  MOVWF  05
0950:  MOVF   64,W
0951:  MOVWF  04
0952:  MOVF   66,W
0953:  MOVWF  00
0954:  MOVF   67,W
0955:  MOVWI  W,[FSR0+01]
0956:  MOVF   68,W
0957:  MOVWI  W,[FSR0+02]
0958:  MOVF   69,W
0959:  MOVWI  W,[FSR0+03]
.................... }
.................... 
.................... void f_get_position(float *latitude, float *longitude, unsigned int32 *fix_age)
.................... {
....................   int32 lat, lon;
....................   get_position(&lat, &lon, fix_age);
*
08CD:  MOVLW  24
08CE:  MOVLB  0F
08CF:  MOVWF  5F
08D0:  MOVLW  E6
08D1:  MOVWF  5E
08D2:  MOVLW  24
08D3:  MOVWF  61
08D4:  MOVLW  EA
08D5:  MOVWF  60
08D6:  MOVF   55,W
08D7:  MOVWF  63
08D8:  MOVF   54,W
08D9:  MOVWF  62
....................   *latitude = lat == GPS_INVALID_ANGLE ? GPS_INVALID_F_ANGLE : (lat / 1000000.0);
*
095A:  MOVF   51,W
095B:  MOVWF  7A
095C:  MOVF   50,W
095D:  MOVWF  04
095E:  MOVF   51,W
095F:  MOVWF  05
0960:  INCFSZ 56,W
0961:  GOTO   175
0962:  MOVF   57,W
0963:  SUBLW  C9
0964:  BTFSS  03.2
0965:  GOTO   175
0966:  MOVF   58,W
0967:  SUBLW  9A
0968:  BTFSS  03.2
0969:  GOTO   175
096A:  MOVF   59,W
096B:  SUBLW  3B
096C:  BTFSS  03.2
096D:  GOTO   175
096E:  MOVLW  88
096F:  MOVWF  77
0970:  MOVLW  7A
0971:  MOVWF  78
0972:  CLRF   79
0973:  CLRF   7A
0974:  GOTO   194
0975:  MOVF   59,W
0976:  MOVWF  63
0977:  MOVF   58,W
0978:  MOVWF  62
0979:  MOVF   57,W
097A:  MOVWF  61
097B:  MOVF   56,W
097C:  MOVWF  60
097D:  MOVLP  00
097E:  MOVLB  00
097F:  CALL   735
0980:  MOVLP  08
0981:  MOVF   7A,W
0982:  MOVLB  0F
0983:  MOVWF  63
0984:  MOVF   79,W
0985:  MOVWF  62
0986:  MOVF   78,W
0987:  MOVWF  61
0988:  MOVF   77,W
0989:  MOVWF  60
098A:  CLRF   67
098B:  MOVLW  24
098C:  MOVWF  66
098D:  MOVLW  74
098E:  MOVWF  65
098F:  MOVLW  92
0990:  MOVWF  64
0991:  MOVLB  00
0992:  CALL   000
0993:  MOVLB  0F
0994:  MOVF   77,W
0995:  MOVWF  00
0996:  MOVF   78,W
0997:  MOVWI  W,[FSR0+01]
0998:  MOVF   79,W
0999:  MOVWI  W,[FSR0+02]
099A:  MOVF   7A,W
099B:  MOVWI  W,[FSR0+03]
....................   *longitude = lat == GPS_INVALID_ANGLE ? GPS_INVALID_F_ANGLE : (lon / 1000000.0);
099C:  MOVF   53,W
099D:  MOVWF  7A
099E:  MOVF   52,W
099F:  MOVWF  04
09A0:  MOVF   53,W
09A1:  MOVWF  05
09A2:  INCFSZ 56,W
09A3:  GOTO   1B7
09A4:  MOVF   57,W
09A5:  SUBLW  C9
09A6:  BTFSS  03.2
09A7:  GOTO   1B7
09A8:  MOVF   58,W
09A9:  SUBLW  9A
09AA:  BTFSS  03.2
09AB:  GOTO   1B7
09AC:  MOVF   59,W
09AD:  SUBLW  3B
09AE:  BTFSS  03.2
09AF:  GOTO   1B7
09B0:  MOVLW  88
09B1:  MOVWF  77
09B2:  MOVLW  7A
09B3:  MOVWF  78
09B4:  CLRF   79
09B5:  CLRF   7A
09B6:  GOTO   1D6
09B7:  MOVF   5D,W
09B8:  MOVWF  63
09B9:  MOVF   5C,W
09BA:  MOVWF  62
09BB:  MOVF   5B,W
09BC:  MOVWF  61
09BD:  MOVF   5A,W
09BE:  MOVWF  60
09BF:  MOVLP  00
09C0:  MOVLB  00
09C1:  CALL   735
09C2:  MOVLP  08
09C3:  MOVF   7A,W
09C4:  MOVLB  0F
09C5:  MOVWF  63
09C6:  MOVF   79,W
09C7:  MOVWF  62
09C8:  MOVF   78,W
09C9:  MOVWF  61
09CA:  MOVF   77,W
09CB:  MOVWF  60
09CC:  CLRF   67
09CD:  MOVLW  24
09CE:  MOVWF  66
09CF:  MOVLW  74
09D0:  MOVWF  65
09D1:  MOVLW  92
09D2:  MOVWF  64
09D3:  MOVLB  00
09D4:  CALL   000
09D5:  MOVLB  0F
09D6:  MOVF   77,W
09D7:  MOVWF  00
09D8:  MOVF   78,W
09D9:  MOVWI  W,[FSR0+01]
09DA:  MOVF   79,W
09DB:  MOVWI  W,[FSR0+02]
09DC:  MOVF   7A,W
09DD:  MOVWI  W,[FSR0+03]
09DE:  MOVLP  08
09DF:  MOVLB  00
09E0:  GOTO   5D9 (RETURN)
.................... 
.................... }
.................... 
.................... int16 gpsstrcmp( char *str1,  char *str2)
.................... {
....................   while (*str1 && *str1 == *str2)
*
00C1:  MOVLB  0F
00C2:  MOVF   57,W
00C3:  MOVWF  7A
00C4:  MOVF   56,W
00C5:  MOVWF  04
00C6:  MOVF   7A,W
00C7:  MOVWF  05
00C8:  MOVF   00,F
00C9:  BTFSC  03.2
00CA:  GOTO   0E4
00CB:  MOVF   57,W
00CC:  MOVWF  7A
00CD:  MOVF   56,W
00CE:  MOVWF  04
00CF:  MOVF   7A,W
00D0:  MOVWF  05
00D1:  MOVF   00,W
00D2:  MOVWF  5A
00D3:  MOVF   59,W
00D4:  MOVWF  7A
00D5:  MOVF   58,W
00D6:  MOVWF  04
00D7:  MOVF   7A,W
00D8:  MOVWF  05
00D9:  MOVF   00,W
00DA:  SUBWF  5A,W
00DB:  BTFSS  03.2
00DC:  GOTO   0E4
....................     ++str1, ++str2;
00DD:  INCF   56,F
00DE:  BTFSC  03.2
00DF:  INCF   57,F
00E0:  INCF   58,F
00E1:  BTFSC  03.2
00E2:  INCF   59,F
00E3:  GOTO   0C2
....................   return *str1;
00E4:  MOVF   57,W
00E5:  MOVWF  7A
00E6:  MOVF   56,W
00E7:  MOVWF  04
00E8:  MOVF   57,W
00E9:  MOVWF  05
00EA:  CLRF   7A
00EB:  MOVF   00,W
00EC:  MOVWF  78
00ED:  MOVF   7A,W
00EE:  MOVWF  79
00EF:  MOVLB  00
00F0:  RETURN
.................... }
.................... 
.................... int16 from_hex(char a)
.................... {
....................   if (a >= 'A' && a <= 'F')
*
0096:  MOVLB  0F
0097:  MOVF   58,W
0098:  SUBLW  40
0099:  BTFSC  03.0
009A:  GOTO   0A8
009B:  MOVF   58,W
009C:  SUBLW  46
009D:  BTFSS  03.0
009E:  GOTO   0A8
....................     return a - 'A' + 10;
009F:  MOVLW  41
00A0:  SUBWF  58,W
00A1:  ADDLW  0A
00A2:  CLRF   7A
00A3:  MOVWF  78
00A4:  MOVF   7A,W
00A5:  MOVWF  79
00A6:  GOTO   0BF
00A7:  GOTO   0BF
....................   else if (a >= 'a' && a <= 'f')
00A8:  MOVF   58,W
00A9:  SUBLW  60
00AA:  BTFSC  03.0
00AB:  GOTO   0B9
00AC:  MOVF   58,W
00AD:  SUBLW  66
00AE:  BTFSS  03.0
00AF:  GOTO   0B9
....................     return a - 'a' + 10;
00B0:  MOVLW  61
00B1:  SUBWF  58,W
00B2:  ADDLW  0A
00B3:  CLRF   7A
00B4:  MOVWF  78
00B5:  MOVF   7A,W
00B6:  MOVWF  79
00B7:  GOTO   0BF
00B8:  GOTO   0BF
....................   else
....................     return a - '0';
00B9:  MOVLW  30
00BA:  SUBWF  58,W
00BB:  CLRF   7A
00BC:  MOVWF  78
00BD:  MOVF   7A,W
00BE:  MOVWF  79
00BF:  MOVLB  00
00C0:  RETURN
.................... }
.................... 
.................... // Parse a string in the form ddmm.mmmmmmm...
.................... unsigned int32 parse_degrees()
*
02CF:  MOVLW  20
02D0:  MOVLB  0F
02D1:  MOVWF  65
02D2:  MOVLW  60
02D3:  MOVWF  64
02D4:  MOVLB  00
02D5:  CALL   12C
02D6:  MOVF   7A,W
02D7:  MOVLB  0F
02D8:  MOVWF  5B
02D9:  MOVF   79,W
02DA:  MOVWF  5A
02DB:  MOVF   78,W
02DC:  MOVWF  59
02DD:  MOVF   77,W
02DE:  MOVWF  58
02DF:  MOVF   05,W
02E0:  MOVWF  65
02E1:  MOVF   04,W
02E2:  MOVWF  64
02E3:  BSF    03.1
02E4:  MOVLW  24
02E5:  MOVWF  05
02E6:  MOVLW  F6
02E7:  MOVWF  04
02E8:  MOVF   5B,W
02E9:  MOVWF  6F
02EA:  MOVF   5A,W
02EB:  MOVWF  6E
02EC:  MOVF   59,W
02ED:  MOVWF  6D
02EE:  MOVF   58,W
02EF:  MOVWF  6C
02F0:  MOVLB  10
02F1:  CLRF   23
02F2:  CLRF   22
02F3:  CLRF   21
02F4:  MOVLW  64
02F5:  MOVWF  20
02F6:  MOVLB  00
02F7:  CALL   27E
02F8:  MOVLB  0F
02F9:  MOVF   66,W
02FA:  MOVWF  77
02FB:  MOVF   67,W
02FC:  MOVWF  78
02FD:  MOVF   68,W
02FE:  MOVWF  79
02FF:  MOVF   69,W
0300:  MOVWF  7A
0301:  MOVF   65,W
0302:  MOVWF  05
0303:  MOVF   64,W
0304:  MOVWF  04
0305:  MOVF   69,W
0306:  MOVWF  6D
0307:  MOVF   68,W
0308:  MOVWF  6C
0309:  MOVF   67,W
030A:  MOVWF  6B
030B:  MOVF   66,W
030C:  MOVWF  6A
030D:  MOVF   05,W
030E:  MOVWF  6F
030F:  MOVF   04,W
0310:  MOVWF  6E
0311:  MOVF   69,W
0312:  MOVLB  10
0313:  MOVWF  23
0314:  MOVLB  0F
0315:  MOVF   68,W
0316:  MOVLB  10
0317:  MOVWF  22
0318:  MOVLB  0F
0319:  MOVF   67,W
031A:  MOVLB  10
031B:  MOVWF  21
031C:  MOVLB  0F
031D:  MOVF   66,W
031E:  MOVLB  10
031F:  MOVWF  20
0320:  CLRF   27
0321:  MOVLW  01
0322:  MOVWF  26
0323:  MOVLW  86
0324:  MOVWF  25
0325:  MOVLW  A0
0326:  MOVWF  24
0327:  MOVLB  00
0328:  CALL   100
0329:  MOVLB  0F
032A:  MOVF   6F,W
032B:  MOVWF  05
032C:  MOVF   6E,W
032D:  MOVWF  04
032E:  MOVF   7A,W
032F:  MOVWF  5F
0330:  MOVF   79,W
0331:  MOVWF  5E
0332:  MOVF   78,W
0333:  MOVWF  5D
0334:  MOVF   77,W
0335:  MOVWF  5C
.................... {
....................   char *p;
....................   unsigned int32 left_of_decimal = gpsatol(_term);
....................   unsigned int32 hundred1000ths_of_minute = (left_of_decimal % 100UL) * 100000UL;
....................   for (p=_term; gpsisdigit(*p); ++p);
0336:  MOVLW  20
0337:  MOVWF  57
0338:  MOVLW  60
0339:  MOVWF  56
033A:  MOVF   57,W
033B:  MOVWF  7A
033C:  MOVF   56,W
033D:  MOVWF  04
033E:  MOVF   57,W
033F:  MOVWF  05
0340:  MOVF   00,W
0341:  MOVWF  64
0342:  MOVWF  6D
0343:  MOVLB  00
0344:  CALL   0F1
0345:  MOVF   78,F
0346:  BTFSC  03.2
0347:  GOTO   34E
0348:  MOVLB  0F
0349:  INCF   56,F
034A:  BTFSC  03.2
034B:  INCF   57,F
034C:  GOTO   33A
034D:  MOVLB  00
....................   if (*p == '.')
034E:  MOVLB  0F
034F:  MOVF   57,W
0350:  MOVWF  7A
0351:  MOVF   56,W
0352:  MOVWF  04
0353:  MOVF   7A,W
0354:  MOVWF  05
0355:  MOVF   00,W
0356:  SUBLW  2E
0357:  BTFSS  03.2
0358:  GOTO   3BE
....................   {
....................     unsigned int32 mult = 10000;
0359:  CLRF   63
035A:  CLRF   62
035B:  MOVLW  27
035C:  MOVWF  61
035D:  MOVLW  10
035E:  MOVWF  60
....................     while (gpsisdigit(*++p))
035F:  INCF   56,F
0360:  BTFSC  03.2
0361:  INCF   57,F
0362:  MOVF   57,W
0363:  MOVWF  7A
0364:  MOVF   56,W
0365:  MOVWF  04
0366:  MOVF   7A,W
0367:  MOVWF  05
0368:  MOVF   00,W
0369:  MOVWF  64
036A:  MOVWF  6D
036B:  MOVLB  00
036C:  CALL   0F1
036D:  MOVF   78,F
036E:  BTFSC  03.2
036F:  GOTO   3BF
....................     {
....................       hundred1000ths_of_minute += mult * (*p - '0');
0370:  MOVLB  0F
0371:  MOVF   57,W
0372:  MOVWF  7A
0373:  MOVF   56,W
0374:  MOVWF  04
0375:  MOVF   57,W
0376:  MOVWF  05
0377:  MOVLW  30
0378:  SUBWF  00,W
0379:  MOVWF  64
037A:  MOVF   05,W
037B:  MOVWF  66
037C:  MOVF   04,W
037D:  MOVWF  65
037E:  MOVF   63,W
037F:  MOVLB  10
0380:  MOVWF  23
0381:  MOVLB  0F
0382:  MOVF   62,W
0383:  MOVLB  10
0384:  MOVWF  22
0385:  MOVLB  0F
0386:  MOVF   61,W
0387:  MOVLB  10
0388:  MOVWF  21
0389:  MOVLB  0F
038A:  MOVF   60,W
038B:  MOVLB  10
038C:  MOVWF  20
038D:  CLRF   27
038E:  CLRF   26
038F:  CLRF   25
0390:  MOVLB  0F
0391:  MOVF   64,W
0392:  MOVLB  10
0393:  MOVWF  24
0394:  MOVLB  00
0395:  CALL   100
0396:  MOVLB  0F
0397:  MOVF   66,W
0398:  MOVWF  05
0399:  MOVF   65,W
039A:  MOVWF  04
039B:  MOVF   77,W
039C:  ADDWF  5C,F
039D:  MOVF   78,W
039E:  ADDWFC 5D,F
039F:  MOVF   79,W
03A0:  ADDWFC 5E,F
03A1:  MOVF   7A,W
03A2:  ADDWFC 5F,F
....................       mult /= 10;
03A3:  BCF    03.1
03A4:  MOVF   63,W
03A5:  MOVWF  6F
03A6:  MOVF   62,W
03A7:  MOVWF  6E
03A8:  MOVF   61,W
03A9:  MOVWF  6D
03AA:  MOVF   60,W
03AB:  MOVWF  6C
03AC:  MOVLB  10
03AD:  CLRF   23
03AE:  CLRF   22
03AF:  CLRF   21
03B0:  MOVLW  0A
03B1:  MOVWF  20
03B2:  MOVLB  00
03B3:  CALL   27E
03B4:  MOVF   7A,W
03B5:  MOVLB  0F
03B6:  MOVWF  63
03B7:  MOVF   79,W
03B8:  MOVWF  62
03B9:  MOVF   78,W
03BA:  MOVWF  61
03BB:  MOVF   77,W
03BC:  MOVWF  60
03BD:  GOTO   35F
03BE:  MOVLB  00
....................     }
....................   }
....................   return (left_of_decimal / 100) * 1000000 + (hundred1000ths_of_minute + 3) / 6;
03BF:  BCF    03.1
03C0:  MOVLB  0F
03C1:  MOVF   5B,W
03C2:  MOVWF  6F
03C3:  MOVF   5A,W
03C4:  MOVWF  6E
03C5:  MOVF   59,W
03C6:  MOVWF  6D
03C7:  MOVF   58,W
03C8:  MOVWF  6C
03C9:  MOVLB  10
03CA:  CLRF   23
03CB:  CLRF   22
03CC:  CLRF   21
03CD:  MOVLW  64
03CE:  MOVWF  20
03CF:  MOVLB  00
03D0:  CALL   27E
03D1:  MOVF   7A,W
03D2:  MOVLB  0F
03D3:  MOVWF  67
03D4:  MOVF   79,W
03D5:  MOVWF  66
03D6:  MOVF   78,W
03D7:  MOVWF  65
03D8:  MOVF   77,W
03D9:  MOVWF  64
03DA:  MOVF   67,W
03DB:  MOVLB  10
03DC:  MOVWF  23
03DD:  MOVLB  0F
03DE:  MOVF   66,W
03DF:  MOVLB  10
03E0:  MOVWF  22
03E1:  MOVLB  0F
03E2:  MOVF   65,W
03E3:  MOVLB  10
03E4:  MOVWF  21
03E5:  MOVLB  0F
03E6:  MOVF   64,W
03E7:  MOVLB  10
03E8:  MOVWF  20
03E9:  CLRF   27
03EA:  MOVLW  0F
03EB:  MOVWF  26
03EC:  MOVLW  42
03ED:  MOVWF  25
03EE:  MOVLW  40
03EF:  MOVWF  24
03F0:  MOVLB  00
03F1:  CALL   100
03F2:  MOVF   7A,W
03F3:  MOVLB  0F
03F4:  MOVWF  67
03F5:  MOVF   79,W
03F6:  MOVWF  66
03F7:  MOVF   78,W
03F8:  MOVWF  65
03F9:  MOVF   77,W
03FA:  MOVWF  64
03FB:  MOVLW  03
03FC:  ADDWF  5C,W
03FD:  MOVWF  68
03FE:  MOVLW  00
03FF:  ADDWFC 5D,W
0400:  MOVWF  69
0401:  MOVLW  00
0402:  ADDWFC 5E,W
0403:  MOVWF  6A
0404:  MOVLW  00
0405:  ADDWFC 5F,W
0406:  MOVWF  6B
0407:  BCF    03.1
0408:  MOVF   6B,W
0409:  MOVWF  6F
040A:  MOVF   6A,W
040B:  MOVWF  6E
040C:  MOVF   69,W
040D:  MOVWF  6D
040E:  MOVF   68,W
040F:  MOVWF  6C
0410:  MOVLB  10
0411:  CLRF   23
0412:  CLRF   22
0413:  CLRF   21
0414:  MOVLW  06
0415:  MOVWF  20
0416:  MOVLB  00
0417:  CALL   27E
0418:  MOVLB  0F
0419:  MOVF   64,W
041A:  ADDWF  77,F
041B:  MOVF   65,W
041C:  ADDWFC 78,F
041D:  MOVF   66,W
041E:  ADDWFC 79,F
041F:  MOVF   67,W
0420:  ADDWFC 7A,F
0421:  MOVLB  00
0422:  RETURN
.................... }
.................... 
.................... 
.................... unsigned int32 parse_decimal()
*
01AF:  MOVLW  20
01B0:  MOVLB  0F
01B1:  MOVWF  57
01B2:  MOVLW  60
01B3:  MOVWF  56
01B4:  BCF    58.0
01B5:  MOVF   57,W
01B6:  MOVWF  7A
01B7:  MOVF   56,W
01B8:  MOVWF  04
01B9:  MOVF   57,W
01BA:  MOVWF  05
01BB:  MOVF   00,W
01BC:  SUBLW  2D
01BD:  BTFSC  03.2
01BE:  BSF    58.0
.................... {
....................   char *p = _term;
....................   boolean isneg = *p == '-';
....................   if (isneg) ++p;
01BF:  BTFSS  58.0
01C0:  GOTO   1C4
01C1:  INCF   56,F
01C2:  BTFSC  03.2
01C3:  INCF   57,F
....................   unsigned int32 ret = 100UL * gpsatol(p);
01C4:  MOVF   57,W
01C5:  MOVWF  65
01C6:  MOVF   56,W
01C7:  MOVWF  64
01C8:  MOVLB  00
01C9:  CALL   12C
01CA:  MOVF   05,W
01CB:  MOVLB  0F
01CC:  MOVWF  5F
01CD:  MOVF   04,W
01CE:  MOVWF  5E
01CF:  MOVLB  10
01D0:  CLRF   23
01D1:  CLRF   22
01D2:  CLRF   21
01D3:  MOVLW  64
01D4:  MOVWF  20
01D5:  MOVF   7A,W
01D6:  MOVWF  27
01D7:  MOVF   79,W
01D8:  MOVWF  26
01D9:  MOVF   78,W
01DA:  MOVWF  25
01DB:  MOVF   77,W
01DC:  MOVWF  24
01DD:  MOVLB  00
01DE:  CALL   100
01DF:  MOVLB  0F
01E0:  MOVF   5F,W
01E1:  MOVWF  05
01E2:  MOVF   5E,W
01E3:  MOVWF  04
01E4:  MOVF   7A,W
01E5:  MOVWF  5C
01E6:  MOVF   79,W
01E7:  MOVWF  5B
01E8:  MOVF   78,W
01E9:  MOVWF  5A
01EA:  MOVF   77,W
01EB:  MOVWF  59
....................   while (gpsisdigit(*p)) ++p;
01EC:  MOVF   57,W
01ED:  MOVWF  7A
01EE:  MOVF   56,W
01EF:  MOVWF  04
01F0:  MOVF   57,W
01F1:  MOVWF  05
01F2:  MOVF   00,W
01F3:  MOVWF  5E
01F4:  MOVWF  6D
01F5:  MOVLB  00
01F6:  CALL   0F1
01F7:  MOVF   78,F
01F8:  BTFSC  03.2
01F9:  GOTO   200
01FA:  MOVLB  0F
01FB:  INCF   56,F
01FC:  BTFSC  03.2
01FD:  INCF   57,F
01FE:  GOTO   1EC
01FF:  MOVLB  00
....................   if (*p == '.')
0200:  MOVLB  0F
0201:  MOVF   57,W
0202:  MOVWF  7A
0203:  MOVF   56,W
0204:  MOVWF  04
0205:  MOVF   7A,W
0206:  MOVWF  05
0207:  MOVF   00,W
0208:  SUBLW  2E
0209:  BTFSS  03.2
020A:  GOTO   248
....................   {
....................     if (gpsisdigit(p[1]))
020B:  MOVF   56,W
020C:  MOVWF  04
020D:  MOVF   57,W
020E:  MOVWF  05
020F:  ADDFSR 01,FSR0
0210:  MOVF   00,W
0211:  MOVWF  5E
0212:  MOVWF  6D
0213:  MOVLB  00
0214:  CALL   0F1
0215:  MOVF   78,F
0216:  BTFSC  03.2
0217:  GOTO   249
....................     {
....................       ret += 10 * (p[1] - '0');
0218:  MOVLB  0F
0219:  MOVF   56,W
021A:  MOVWF  04
021B:  MOVF   57,W
021C:  MOVWF  05
021D:  ADDFSR 01,FSR0
021E:  MOVLW  30
021F:  SUBWF  00,W
0220:  MOVWF  5E
0221:  MOVLW  0A
0222:  MOVWF  5F
0223:  MOVF   5E,W
0224:  MOVWF  60
0225:  MOVLB  00
0226:  CALL   188
0227:  MOVF   78,W
0228:  MOVLB  0F
0229:  ADDWF  59,F
022A:  MOVLW  00
022B:  ADDWFC 5A,F
022C:  ADDWFC 5B,F
022D:  ADDWFC 5C,F
....................       if (gpsisdigit(p[2]))
022E:  MOVF   56,W
022F:  MOVWF  04
0230:  MOVF   57,W
0231:  MOVWF  05
0232:  ADDFSR 02,FSR0
0233:  MOVF   00,W
0234:  MOVWF  5E
0235:  MOVWF  6D
0236:  MOVLB  00
0237:  CALL   0F1
0238:  MOVF   78,F
0239:  BTFSC  03.2
023A:  GOTO   249
....................         ret += p[2] - '0';
023B:  MOVLB  0F
023C:  MOVF   56,W
023D:  MOVWF  04
023E:  MOVF   57,W
023F:  MOVWF  05
0240:  ADDFSR 02,FSR0
0241:  MOVLW  30
0242:  SUBWF  00,W
0243:  ADDWF  59,F
0244:  MOVLW  00
0245:  ADDWFC 5A,F
0246:  ADDWFC 5B,F
0247:  ADDWFC 5C,F
0248:  MOVLB  00
....................     }
....................   }
....................   return isneg ? -ret : ret;
0249:  MOVLB  0F
024A:  BTFSS  58.0
024B:  GOTO   25C
024C:  MOVF   59,W
024D:  SUBLW  00
024E:  MOVWF  77
024F:  MOVLW  00
0250:  MOVWF  78
0251:  MOVF   5A,W
0252:  SUBWFC 78,F
0253:  MOVLW  00
0254:  MOVWF  79
0255:  MOVF   5B,W
0256:  SUBWFC 79,F
0257:  MOVLW  00
0258:  MOVWF  7A
0259:  MOVF   5C,W
025A:  SUBWFC 7A,F
025B:  GOTO   264
025C:  MOVF   59,W
025D:  MOVWF  77
025E:  MOVF   5A,W
025F:  MOVWF  78
0260:  MOVF   5B,W
0261:  MOVWF  79
0262:  MOVF   5C,W
0263:  MOVWF  7A
0264:  MOVLB  00
0265:  RETURN
.................... }
.................... 
.................... int32 gpsatol( char *str)
*
012C:  MOVLB  0F
012D:  CLRF   69
012E:  CLRF   68
012F:  CLRF   67
0130:  CLRF   66
.................... {
.................... 
....................   int32 ret = 0;
....................   //putchar('<',USER);
....................   while (gpsisdigit(*str)){
0131:  MOVF   65,W
0132:  MOVWF  7A
0133:  MOVF   64,W
0134:  MOVWF  04
0135:  MOVF   7A,W
0136:  MOVWF  05
0137:  MOVF   00,W
0138:  MOVWF  6C
0139:  MOVWF  6D
013A:  MOVLB  00
013B:  CALL   0F1
013C:  MOVF   78,F
013D:  BTFSC  03.2
013E:  GOTO   17D
....................   //putchar(*str,USER);
....................     ret = 10 * ret + *str++ - '0';
013F:  MOVLB  10
0140:  CLRF   23
0141:  CLRF   22
0142:  CLRF   21
0143:  MOVLW  0A
0144:  MOVWF  20
0145:  MOVLB  0F
0146:  MOVF   69,W
0147:  MOVLB  10
0148:  MOVWF  27
0149:  MOVLB  0F
014A:  MOVF   68,W
014B:  MOVLB  10
014C:  MOVWF  26
014D:  MOVLB  0F
014E:  MOVF   67,W
014F:  MOVLB  10
0150:  MOVWF  25
0151:  MOVLB  0F
0152:  MOVF   66,W
0153:  MOVLB  10
0154:  MOVWF  24
0155:  MOVLB  00
0156:  CALL   100
0157:  MOVF   7A,W
0158:  MOVLB  0F
0159:  MOVWF  6F
015A:  MOVF   79,W
015B:  MOVWF  6E
015C:  MOVF   78,W
015D:  MOVWF  6D
015E:  MOVF   77,W
015F:  MOVWF  6C
0160:  MOVF   65,W
0161:  MOVWF  7A
0162:  MOVF   64,W
0163:  INCF   64,F
0164:  BTFSC  03.2
0165:  INCF   65,F
0166:  MOVWF  04
0167:  MOVF   7A,W
0168:  MOVWF  05
0169:  MOVF   00,W
016A:  ADDWF  6C,F
016B:  MOVLW  00
016C:  ADDWFC 6D,F
016D:  ADDWFC 6E,F
016E:  ADDWFC 6F,F
016F:  MOVLW  30
0170:  SUBWF  6C,W
0171:  MOVWF  66
0172:  MOVLW  00
0173:  SUBWFC 6D,W
0174:  MOVWF  67
0175:  MOVLW  00
0176:  SUBWFC 6E,W
0177:  MOVWF  68
0178:  MOVLW  00
0179:  SUBWFC 6F,W
017A:  MOVWF  69
017B:  GOTO   131
017C:  MOVLB  00
....................   }
....................   //putchar('\n',USER);
....................   //fprintf(USER," ! %ld \n",ret);
....................   return ret;
017D:  MOVLB  0F
017E:  MOVF   66,W
017F:  MOVWF  77
0180:  MOVF   67,W
0181:  MOVWF  78
0182:  MOVF   68,W
0183:  MOVWF  79
0184:  MOVF   69,W
0185:  MOVWF  7A
0186:  MOVLB  00
0187:  RETURN
.................... }
.................... 
.................... //TinyGPS::TinyGPS()
.................... void tinyGPS_init(){
.................... _time = (GPS_INVALID_TIME);
.................... _date=(GPS_INVALID_DATE);
.................... _latitude=(GPS_INVALID_ANGLE);
.................... _longitude=(GPS_INVALID_ANGLE);
.................... _altitude=(GPS_INVALID_ALTITUDE);
.................... _speed=(GPS_INVALID_SPEED);
.................... _course=(GPS_INVALID_ANGLE);
.................... _hdop=(GPS_INVALID_HDOP);
.................... _numsats=(GPS_INVALID_SATELLITES);
.................... _last_time_fix=(GPS_INVALID_FIX_TIME);
.................... _last_position_fix=(GPS_INVALID_FIX_TIME);
.................... _parity=(0);
.................... _is_checksum_term=(false);
.................... _sentence_type=(_GPS_SENTENCE_OTHER);
.................... _term_number=(0);
.................... _term_offset=(0);
.................... _gps_data_good=(false);
.................... #ifndef _GPS_NO_STATS
.................... _encoded_characters=(0);
.................... _good_sentences=(0);
.................... _failed_checksum=(0);
.................... #endif
.................... _term[0] = '\0';
.................... }
.................... 
.................... boolean encode(char c)
*
06D0:  MOVLB  0F
06D1:  BCF    52.0
.................... {
....................   boolean valid_sentence = false;
.................... 
.................... #ifndef _GPS_NO_STATS
....................   ++_encoded_characters;
.................... #endif
....................   switch(c)
06D2:  MOVF   51,W
06D3:  XORLW  2C
06D4:  MOVLB  00
06D5:  BTFSC  03.2
06D6:  GOTO   6E4
06D7:  XORLW  21
06D8:  BTFSC  03.2
06D9:  GOTO   6E8
06DA:  XORLW  07
06DB:  BTFSC  03.2
06DC:  GOTO   6E8
06DD:  XORLW  20
06DE:  BTFSC  03.2
06DF:  GOTO   6E8
06E0:  XORLW  0E
06E1:  BTFSC  03.2
06E2:  GOTO   708
06E3:  GOTO   717
....................   {
....................   case ',': // term terminators
....................     _parity ^= c;
06E4:  MOVLB  0F
06E5:  MOVF   51,W
06E6:  MOVLB  00
06E7:  XORWF  6F,F
....................   case '\r':
....................   case '\n':
....................   case '*':
....................     if (_term_offset < sizeof(_term))
06E8:  MOVF   73,W
06E9:  SUBLW  0E
06EA:  BTFSS  03.0
06EB:  GOTO   6FA
....................     {
....................       _term[_term_offset] = 0;
06EC:  MOVLW  60
06ED:  ADDWF  73,W
06EE:  MOVWF  04
06EF:  MOVLW  20
06F0:  MOVWF  05
06F1:  BTFSC  03.0
06F2:  INCF   05,F
06F3:  CLRF   00
....................       valid_sentence = term_complete();
06F4:  GOTO   423
06F5:  MOVLB  0F
06F6:  BCF    52.0
06F7:  BTFSC  78.0
06F8:  BSF    52.0
06F9:  MOVLB  00
....................     }
....................     ++_term_number;
06FA:  INCF   72,F
....................     _term_offset = 0;
06FB:  CLRF   73
....................     _is_checksum_term = c == '*';
06FC:  BCF    70.0
06FD:  MOVLB  0F
06FE:  MOVF   51,W
06FF:  SUBLW  2A
0700:  BTFSC  03.2
0701:  BSF    70.0
....................     return valid_sentence;
0702:  MOVLW  00
0703:  BTFSC  52.0
0704:  MOVLW  01
0705:  MOVWF  78
0706:  GOTO   732
0707:  MOVLB  00
.................... 
....................   case '$': // sentence begin
....................     _term_number = _term_offset = 0;
0708:  CLRF   73
0709:  MOVF   73,W
070A:  MOVWF  72
....................     _parity = 0;
070B:  CLRF   6F
....................     _sentence_type = _GPS_SENTENCE_OTHER;
070C:  MOVLW  02
070D:  MOVWF  71
....................     _is_checksum_term = false;
070E:  BCF    70.0
....................     _gps_data_good = false;
070F:  BCF    70.1
....................     return valid_sentence;
0710:  MOVLW  00
0711:  MOVLB  0F
0712:  BTFSC  52.0
0713:  MOVLW  01
0714:  MOVWF  78
0715:  GOTO   732
0716:  MOVLB  00
....................   }
.................... 
....................   // ordinary characters
....................   if (_term_offset < sizeof(_term) - 1)
0717:  MOVF   73,W
0718:  SUBLW  0D
0719:  BTFSS  03.0
071A:  GOTO   727
....................     _term[_term_offset++] = c;
071B:  MOVF   73,W
071C:  INCF   73,F
071D:  ADDLW  60
071E:  MOVWF  04
071F:  MOVLW  20
0720:  MOVWF  05
0721:  BTFSC  03.0
0722:  INCF   05,F
0723:  MOVLB  0F
0724:  MOVF   51,W
0725:  MOVWF  00
0726:  MOVLB  00
....................   if (!_is_checksum_term)
0727:  BTFSC  70.0
0728:  GOTO   72D
....................     _parity ^= c;
0729:  MOVLB  0F
072A:  MOVF   51,W
072B:  MOVLB  00
072C:  XORWF  6F,F
.................... 
....................   return valid_sentence;
072D:  MOVLW  00
072E:  MOVLB  0F
072F:  BTFSC  52.0
0730:  MOVLW  01
0731:  MOVWF  78
0732:  MOVLP  08
0733:  MOVLB  00
0734:  GOTO   5AE (RETURN)
.................... }
.................... 
.................... // Processes a just-completed term
.................... // Returns true if new sentence has just passed checksum test and is validated
.................... //bool TinyGPS::
.................... boolean term_complete()
.................... {
....................   if (_is_checksum_term)
*
0423:  BTFSS  70.0
0424:  GOTO   4CD
....................   {
....................     byte checksum = 16 * from_hex(_term[0]) + from_hex(_term[1]);
0425:  MOVLB  01
0426:  MOVF   30,W
0427:  MOVLB  0F
0428:  MOVWF  58
0429:  MOVLB  00
042A:  CALL   096
042B:  MOVF   79,W
042C:  MOVWF  7A
042D:  MOVF   78,W
042E:  MOVWF  79
042F:  RLF    78,W
0430:  MOVLB  0F
0431:  MOVWF  56
0432:  RLF    7A,W
0433:  MOVWF  57
0434:  RLF    56,F
0435:  RLF    57,F
0436:  RLF    56,F
0437:  RLF    57,F
0438:  RLF    56,F
0439:  RLF    57,F
043A:  MOVLW  F0
043B:  ANDWF  56,F
043C:  MOVLB  01
043D:  MOVF   31,W
043E:  MOVLB  0F
043F:  MOVWF  58
0440:  MOVLB  00
0441:  CALL   096
0442:  MOVF   78,W
0443:  MOVLB  0F
0444:  ADDWF  56,W
0445:  MOVWF  54
....................     if (checksum == _parity)
0446:  MOVLB  00
0447:  MOVF   6F,W
0448:  MOVLB  0F
0449:  SUBWF  54,W
044A:  BTFSS  03.2
044B:  GOTO   4C9
....................     {
....................       if (_gps_data_good)
044C:  BTFSS  70.1
044D:  GOTO   4C9
....................       {
.................... #ifndef _GPS_NO_STATS
....................         ++_good_sentences;
.................... #endif
....................         _last_time_fix = _new_time_fix;
044E:  MOVLB  01
044F:  MOVF   27,W
0450:  MOVWF  23
0451:  MOVF   26,W
0452:  MOVWF  22
0453:  MOVF   25,W
0454:  MOVWF  21
0455:  MOVF   24,W
0456:  MOVWF  20
....................         _last_position_fix = _new_position_fix;
0457:  MOVF   2F,W
0458:  MOVWF  2B
0459:  MOVF   2E,W
045A:  MOVWF  2A
045B:  MOVF   2D,W
045C:  MOVWF  29
045D:  MOVF   2C,W
045E:  MOVWF  28
.................... 
....................         switch(_sentence_type)
045F:  MOVF   71,W
0460:  XORLW  01
0461:  MOVLB  00
0462:  BTFSC  03.2
0463:  GOTO   468
0464:  XORLW  01
0465:  BTFSC  03.2
0466:  GOTO   499
0467:  GOTO   4C5
....................         {
....................         case _GPS_SENTENCE_GPRMC:
....................           _time      = _new_time;
0468:  MOVF   32,W
0469:  MOVWF  2E
046A:  MOVF   31,W
046B:  MOVWF  2D
046C:  MOVF   30,W
046D:  MOVWF  2C
046E:  MOVF   2F,W
046F:  MOVWF  2B
....................           _date      = _new_date;
0470:  MOVF   3A,W
0471:  MOVWF  36
0472:  MOVF   39,W
0473:  MOVWF  35
0474:  MOVF   38,W
0475:  MOVWF  34
0476:  MOVF   37,W
0477:  MOVWF  33
....................           _latitude  = _new_latitude;
0478:  MOVF   42,W
0479:  MOVWF  3E
047A:  MOVF   41,W
047B:  MOVWF  3D
047C:  MOVF   40,W
047D:  MOVWF  3C
047E:  MOVF   3F,W
047F:  MOVWF  3B
....................           _longitude = _new_longitude;
0480:  MOVF   4A,W
0481:  MOVWF  46
0482:  MOVF   49,W
0483:  MOVWF  45
0484:  MOVF   48,W
0485:  MOVWF  44
0486:  MOVF   47,W
0487:  MOVWF  43
....................           _speed     = _new_speed;
0488:  MOVF   5A,W
0489:  MOVWF  56
048A:  MOVF   59,W
048B:  MOVWF  55
048C:  MOVF   58,W
048D:  MOVWF  54
048E:  MOVF   57,W
048F:  MOVWF  53
....................           _course    = _new_course;
0490:  MOVF   62,W
0491:  MOVWF  5E
0492:  MOVF   61,W
0493:  MOVWF  5D
0494:  MOVF   60,W
0495:  MOVWF  5C
0496:  MOVF   5F,W
0497:  MOVWF  5B
....................           break;
0498:  GOTO   4C5
....................         case _GPS_SENTENCE_GPGGA:
....................           _altitude  = _new_altitude;
0499:  MOVF   52,W
049A:  MOVWF  4E
049B:  MOVF   51,W
049C:  MOVWF  4D
049D:  MOVF   50,W
049E:  MOVWF  4C
049F:  MOVF   4F,W
04A0:  MOVWF  4B
....................           _time      = _new_time;
04A1:  MOVF   32,W
04A2:  MOVWF  2E
04A3:  MOVF   31,W
04A4:  MOVWF  2D
04A5:  MOVF   30,W
04A6:  MOVWF  2C
04A7:  MOVF   2F,W
04A8:  MOVWF  2B
....................           _latitude  = _new_latitude;
04A9:  MOVF   42,W
04AA:  MOVWF  3E
04AB:  MOVF   41,W
04AC:  MOVWF  3D
04AD:  MOVF   40,W
04AE:  MOVWF  3C
04AF:  MOVF   3F,W
04B0:  MOVWF  3B
....................           _longitude = _new_longitude;
04B1:  MOVF   4A,W
04B2:  MOVWF  46
04B3:  MOVF   49,W
04B4:  MOVWF  45
04B5:  MOVF   48,W
04B6:  MOVWF  44
04B7:  MOVF   47,W
04B8:  MOVWF  43
....................           _numsats   = _new_numsats;
04B9:  MOVF   6E,W
04BA:  MOVWF  6C
04BB:  MOVF   6D,W
04BC:  MOVWF  6B
....................           _hdop      = _new_hdop;
04BD:  MOVF   6A,W
04BE:  MOVWF  66
04BF:  MOVF   69,W
04C0:  MOVWF  65
04C1:  MOVF   68,W
04C2:  MOVWF  64
04C3:  MOVF   67,W
04C4:  MOVWF  63
....................           break;
....................         }
....................         return true;
04C5:  MOVLW  01
04C6:  MOVWF  78
04C7:  GOTO   6A1
04C8:  MOVLB  0F
....................       }
....................     }
.................... 
.................... #ifndef _GPS_NO_STATS
....................     else
....................       ++_failed_checksum;
.................... #endif
....................     return false;
04C9:  MOVLW  00
04CA:  MOVWF  78
04CB:  MOVLB  00
04CC:  GOTO   6A1
....................   }
.................... 
....................   // the first term determines the sentence type
....................   if (_term_number == 0)
04CD:  MOVF   72,F
04CE:  BTFSS  03.2
04CF:  GOTO   4F8
....................   {
....................     if (!gpsstrcmp(_term, _GPRMC_TERM))
04D0:  MOVLW  20
04D1:  MOVLB  0F
04D2:  MOVWF  57
04D3:  MOVLW  60
04D4:  MOVWF  56
04D5:  MOVLW  20
04D6:  MOVWF  59
04D7:  MOVLW  6F
04D8:  MOVWF  58
04D9:  MOVLB  00
04DA:  CALL   0C1
04DB:  MOVF   78,W
04DC:  IORWF  79,W
04DD:  BTFSS  03.2
04DE:  GOTO   4E2
....................       _sentence_type = _GPS_SENTENCE_GPRMC;
04DF:  MOVLW  01
04E0:  MOVWF  71
04E1:  GOTO   4F5
....................     else{ 
....................       if (!gpsstrcmp(_term, _GPGGA_TERM)){      _sentence_type = _GPS_SENTENCE_GPGGA;}
04E2:  MOVLW  20
04E3:  MOVLB  0F
04E4:  MOVWF  57
04E5:  MOVLW  60
04E6:  MOVWF  56
04E7:  MOVLW  20
04E8:  MOVWF  59
04E9:  MOVLW  75
04EA:  MOVWF  58
04EB:  MOVLB  00
04EC:  CALL   0C1
04ED:  MOVF   78,W
04EE:  IORWF  79,W
04EF:  BTFSS  03.2
04F0:  GOTO   4F3
04F1:  CLRF   71
04F2:  GOTO   4F5
....................       else{      _sentence_type = _GPS_SENTENCE_OTHER;}
04F3:  MOVLW  02
04F4:  MOVWF  71
....................     }
....................     return false;
04F5:  MOVLW  00
04F6:  MOVWF  78
04F7:  GOTO   6A1
....................   }
.................... 
....................   if (_sentence_type != _GPS_SENTENCE_OTHER && _term[0])
04F8:  MOVF   71,W
04F9:  SUBLW  02
04FA:  BTFSC  03.2
04FB:  GOTO   69D
04FC:  MOVLB  01
04FD:  MOVF   30,F
04FE:  BTFSS  03.2
04FF:  GOTO   502
0500:  MOVLB  00
0501:  GOTO   69D
....................     switch(COMBINE(_sentence_type, _term_number))
0502:  SWAPF  71,W
0503:  MOVWF  77
0504:  RLF    77,F
0505:  MOVLW  E0
0506:  ANDWF  77,F
0507:  MOVF   77,W
0508:  IORWF  72,W
0509:  ADDLW  FF
050A:  ADDLW  D7
050B:  BTFSC  03.0
050C:  GOTO   69E
050D:  ADDLW  29
050E:  MOVLB  00
050F:  GOTO   6A3
....................   {
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 1): // Time in both sentences
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 1):
....................       _new_time = parse_decimal();
0510:  CALL   1AF
0511:  MOVF   7A,W
0512:  MOVWF  32
0513:  MOVF   79,W
0514:  MOVWF  31
0515:  MOVF   78,W
0516:  MOVWF  30
0517:  MOVF   77,W
0518:  MOVWF  2F
....................       _new_time_fix = millis();
0519:  CALL   266
051A:  MOVF   7A,W
051B:  MOVLB  01
051C:  MOVWF  27
051D:  MOVF   79,W
051E:  MOVWF  26
051F:  MOVF   78,W
0520:  MOVWF  25
0521:  MOVF   77,W
0522:  MOVWF  24
....................       break;
0523:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 2): // GPRMC validity
....................       _gps_data_good = _term[0] == 'A';
0524:  BCF    70.1
0525:  MOVLB  01
0526:  MOVF   30,W
0527:  SUBLW  41
0528:  BTFSC  03.2
0529:  BSF    70.1
....................       break;
052A:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 3): // Latitude
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 2):
....................       _new_latitude = parse_degrees();
052B:  CALL   2CF
052C:  MOVF   7A,W
052D:  MOVWF  42
052E:  MOVF   79,W
052F:  MOVWF  41
0530:  MOVF   78,W
0531:  MOVWF  40
0532:  MOVF   77,W
0533:  MOVWF  3F
....................       _new_position_fix = millis();
0534:  CALL   266
0535:  MOVF   7A,W
0536:  MOVLB  01
0537:  MOVWF  2F
0538:  MOVF   79,W
0539:  MOVWF  2E
053A:  MOVF   78,W
053B:  MOVWF  2D
053C:  MOVF   77,W
053D:  MOVWF  2C
....................       break;
053E:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 4): // N/S
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 3):
....................       if (_term[0] == 'S')
053F:  MOVLB  01
0540:  MOVF   30,W
0541:  SUBLW  53
0542:  BTFSS  03.2
0543:  GOTO   551
....................         _new_latitude = -_new_latitude;
0544:  MOVLB  00
0545:  COMF   3F,F
0546:  COMF   40,F
0547:  COMF   41,F
0548:  COMF   42,F
0549:  INCF   3F,F
054A:  BTFSC  03.2
054B:  INCF   40,F
054C:  BTFSC  03.2
054D:  INCF   41,F
054E:  BTFSC  03.2
054F:  INCF   42,F
0550:  MOVLB  01
....................       break;
0551:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 5): // Longitude
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 4):
....................       _new_longitude = parse_degrees();
0552:  CALL   2CF
0553:  MOVF   7A,W
0554:  MOVWF  4A
0555:  MOVF   79,W
0556:  MOVWF  49
0557:  MOVF   78,W
0558:  MOVWF  48
0559:  MOVF   77,W
055A:  MOVWF  47
....................       break;
055B:  MOVLB  01
055C:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 6): // E/W
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 5):
....................       if (_term[0] == 'W')
055D:  MOVLB  01
055E:  MOVF   30,W
055F:  SUBLW  57
0560:  BTFSS  03.2
0561:  GOTO   56F
....................         _new_longitude = -_new_longitude;
0562:  MOVLB  00
0563:  COMF   47,F
0564:  COMF   48,F
0565:  COMF   49,F
0566:  COMF   4A,F
0567:  INCF   47,F
0568:  BTFSC  03.2
0569:  INCF   48,F
056A:  BTFSC  03.2
056B:  INCF   49,F
056C:  BTFSC  03.2
056D:  INCF   4A,F
056E:  MOVLB  01
....................       break;
056F:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 7): // Speed (GPRMC)
....................       _new_speed = parse_decimal();
0570:  CALL   1AF
0571:  MOVF   7A,W
0572:  MOVWF  5A
0573:  MOVF   79,W
0574:  MOVWF  59
0575:  MOVF   78,W
0576:  MOVWF  58
0577:  MOVF   77,W
0578:  MOVWF  57
....................       break;
0579:  MOVLB  01
057A:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 8): // Course (GPRMC)
....................       _new_course = parse_decimal();
057B:  CALL   1AF
057C:  MOVF   7A,W
057D:  MOVWF  62
057E:  MOVF   79,W
057F:  MOVWF  61
0580:  MOVF   78,W
0581:  MOVWF  60
0582:  MOVF   77,W
0583:  MOVWF  5F
....................       break;
0584:  MOVLB  01
0585:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPRMC, 9): // Date (GPRMC)
....................       _new_date = gpsatol(_term);
0586:  MOVLW  20
0587:  MOVLB  0F
0588:  MOVWF  65
0589:  MOVLW  60
058A:  MOVWF  64
058B:  MOVLB  00
058C:  CALL   12C
058D:  MOVF   7A,W
058E:  MOVWF  3A
058F:  MOVF   79,W
0590:  MOVWF  39
0591:  MOVF   78,W
0592:  MOVWF  38
0593:  MOVF   77,W
0594:  MOVWF  37
....................       break;
0595:  MOVLB  01
0596:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 6): // Fix data (GPGGA)
....................       _gps_data_good = _term[0] > '0';
0597:  BCF    70.1
0598:  MOVLB  01
0599:  MOVF   30,W
059A:  SUBLW  30
059B:  BTFSS  03.0
059C:  BSF    70.1
....................       break;
059D:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 7): // Satellites used (GPGGA)
....................       _new_numsats = (unsigned char)atoi(_term);
059E:  MOVLW  20
059F:  MOVLB  0F
05A0:  MOVWF  57
05A1:  MOVLW  60
05A2:  MOVWF  56
*
0681:  MOVLB  00
0682:  CLRF   6E
0683:  MOVF   78,W
0684:  MOVWF  6D
....................       break;
0685:  MOVLB  01
0686:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 8): // HDOP
....................       _new_hdop = parse_decimal();
0687:  CALL   1AF
0688:  MOVF   7A,W
0689:  MOVWF  6A
068A:  MOVF   79,W
068B:  MOVWF  69
068C:  MOVF   78,W
068D:  MOVWF  68
068E:  MOVF   77,W
068F:  MOVWF  67
....................       break;
0690:  MOVLB  01
0691:  GOTO   69E
....................     case COMBINE(_GPS_SENTENCE_GPGGA, 9): // Altitude (GPGGA)
....................       _new_altitude = parse_decimal();
0692:  CALL   1AF
0693:  MOVF   7A,W
0694:  MOVWF  52
0695:  MOVF   79,W
0696:  MOVWF  51
0697:  MOVF   78,W
0698:  MOVWF  50
0699:  MOVF   77,W
069A:  MOVWF  4F
....................       break;
069B:  MOVLB  01
069C:  GOTO   69E
069D:  MOVLB  01
....................   }
.................... 
....................   return false;
069E:  MOVLW  00
069F:  MOVWF  78
06A0:  MOVLB  00
06A1:  MOVLP  00
06A2:  GOTO   6F5 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... char C__;
.................... boolean newData = false;
.................... char buff[1000];
.................... float flat, flon;
.................... unsigned INT32 age;
.................... char a[100] = "";
.................... 
.................... void decodeString()
.................... {
....................    INT i=0;
.................... 
....................    WHILE (a[i] != '\0')
....................    {
....................       putchar (a[i], UBLOX);
....................       newData = encode (a[i]);
....................       i++;
....................    }
.................... }
.................... 
.................... /*
.................... void main()
.................... {
....................    setup_lcd (LCD_DISABLED) ;
.................... 
....................    WHILE (TRUE)
....................    {
....................       putchar (getchar (UBLOX), UBLOX) ;
....................    }
.................... }*/
.................... /*
.................... void main()
.................... {
....................    setup_lcd (LCD_DISABLED) ;
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................    fprintf (UBLOX, "BOOT ! \r\n\r\n\r\n") ;
....................    
....................    WHILE (TRUE)
....................    {
....................       putchar ('+', UBLOX);
....................       for (INT n = 0; n < 200; n++){ 
....................       //buff[i] = getchar (UBLOX);  
....................       C__ = getchar (UBLOX);  
....................       buff[n] = C__;
....................       putchar(C__,UBLOX);
....................       }
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('\n', UBLOX);
....................       putchar ('*', UBLOX);
....................       delay_ms(100);
....................       putchar ('@', UBLOX);
....................       putchar ('\n', UBLOX);
....................       
....................       for (INT n = 0; n < 200; n++){       putchar(buff[n],UBLOX);      }
....................    }
.................... }*/
.................... 
.................... void main()
*
0C80:  MOVLW  55
0C81:  MOVLB  3D
0C82:  MOVWF  0F
0C83:  MOVLW  AA
0C84:  MOVWF  0F
0C85:  BCF    0F.0
0C86:  MOVLW  17
0C87:  MOVWF  4B
0C88:  MOVLW  0D
0C89:  MOVLB  3E
0C8A:  MOVWF  26
0C8B:  MOVLW  55
0C8C:  MOVLB  3D
0C8D:  MOVWF  0F
0C8E:  MOVLW  AA
0C8F:  MOVWF  0F
0C90:  BSF    0F.0
0C91:  MOVLB  11
0C92:  CLRF   12
0C93:  CLRF   0F
0C94:  CLRF   11
0C95:  CLRF   13
0C96:  MOVLW  60
0C97:  MOVWF  0D
0C98:  MOVLB  00
0C99:  CLRF   20
0C9A:  MOVLB  02
0C9B:  BSF    1F.3
0C9C:  MOVLW  19
0C9D:  MOVWF  1B
0C9E:  MOVLW  00
0C9F:  MOVWF  1C
0CA0:  MOVLW  A6
0CA1:  MOVWF  1E
0CA2:  MOVLW  90
0CA3:  MOVWF  1D
0CA4:  MOVLB  00
0CA5:  CLRF   24
0CA6:  CLRF   23
0CA7:  CLRF   22
0CA8:  CLRF   21
0CA9:  BCF    70.2
0CAA:  MOVLB  0F
0CAB:  CLRF   44
0CAC:  CLRF   43
0CAD:  MOVLB  3A
0CAE:  CLRF   0C
0CAF:  CLRF   0D
0CB0:  CLRF   0E
0CB1:  CLRF   0F
0CB2:  CLRF   10
0CB3:  CLRF   11
0CB4:  CLRF   12
0CB5:  CLRF   13
0CB6:  MOVLB  3E
0CB7:  CLRF   38
0CB8:  CLRF   43
0CB9:  CLRF   4E
0CBA:  MOVLB  13
0CBB:  CLRF   11
0CBC:  CLRF   12
0CBD:  CLRF   13
0CBE:  CLRF   10
0CBF:  CLRF   15
0CC0:  CLRF   16
0CC1:  CLRF   17
0CC2:  CLRF   14
0CC3:  MOVLB  00
0CC4:  CLRF   25
0CC5:  CLRF   26
0CC6:  MOVLW  47
0CC7:  MOVLB  01
0CC8:  MOVWF  3F
0CC9:  MOVLW  50
0CCA:  MOVWF  40
0CCB:  MOVLW  52
0CCC:  MOVWF  41
0CCD:  MOVLW  4D
0CCE:  MOVWF  42
0CCF:  MOVLW  43
0CD0:  MOVWF  43
0CD1:  CLRF   44
0CD2:  MOVLW  47
0CD3:  MOVWF  45
0CD4:  MOVLW  50
0CD5:  MOVWF  46
0CD6:  MOVLW  47
0CD7:  MOVWF  47
0CD8:  MOVWF  48
0CD9:  MOVLW  41
0CDA:  MOVWF  49
0CDB:  CLRF   4A
0CDC:  MOVLB  0E
0CDD:  CLRF   2F
.................... {
....................    setup_lcd (LCD_DISABLED) ;
0CDE:  MOVLB  3A
0CDF:  CLRF   17
0CE0:  CLRF   15
0CE1:  CLRF   14
0CE2:  CLRF   0D
0CE3:  CLRF   0C
....................    //enable_interrupts (INT_RDA) ;
....................    //enable_interrupts (GLOBAL) ;
....................       putchar ('\n', UBLOX);
0CE4:  MOVLW  0A
0CE5:  MOVLB  0F
0CE6:  MOVWF  60
0CE7:  MOVLP  00
0CE8:  MOVLB  00
0CE9:  CALL   01D
0CEA:  MOVLP  08
....................       putchar ('\n', UBLOX);
0CEB:  MOVLW  0A
0CEC:  MOVLB  0F
0CED:  MOVWF  60
0CEE:  MOVLP  00
0CEF:  MOVLB  00
0CF0:  CALL   01D
0CF1:  MOVLP  08
....................       putchar ('\n', UBLOX);
0CF2:  MOVLW  0A
0CF3:  MOVLB  0F
0CF4:  MOVWF  60
0CF5:  MOVLP  00
0CF6:  MOVLB  00
0CF7:  CALL   01D
0CF8:  MOVLP  08
....................       putchar ('\n', UBLOX);
0CF9:  MOVLW  0A
0CFA:  MOVLB  0F
0CFB:  MOVWF  60
0CFC:  MOVLP  00
0CFD:  MOVLB  00
0CFE:  CALL   01D
0CFF:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D00:  MOVLW  0A
0D01:  MOVLB  0F
0D02:  MOVWF  60
0D03:  MOVLP  00
0D04:  MOVLB  00
0D05:  CALL   01D
0D06:  MOVLP  08
....................    fprintf (UBLOX, "BOOT ! \r\n\r\n\r\n") ;
0D07:  MOVLW  03
0D08:  MOVLB  10
0D09:  MOVWF  1A
0D0A:  MOVLW  00
0D0B:  MOVWF  1B
0D0C:  MOVLP  00
0D0D:  MOVLB  00
0D0E:  GOTO   026
0D0F:  MOVLP  08
....................    
....................    WHILE (TRUE)
....................    {
....................       delay_ms(60000);
0D10:  MOVLW  F0
0D11:  MOVLB  0F
0D12:  MOVWF  50
0D13:  MOVLW  FA
0D14:  MOVWF  51
0D15:  MOVLP  00
0D16:  MOVLB  00
0D17:  CALL   075
0D18:  MOVLP  08
0D19:  MOVLB  0F
0D1A:  DECFSZ 50,F
0D1B:  GOTO   513
....................       
....................       putchar ('\n', UBLOX);
0D1C:  MOVLW  0A
0D1D:  MOVWF  60
0D1E:  MOVLP  00
0D1F:  MOVLB  00
0D20:  CALL   01D
0D21:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D22:  MOVLW  0A
0D23:  MOVLB  0F
0D24:  MOVWF  60
0D25:  MOVLP  00
0D26:  MOVLB  00
0D27:  CALL   01D
0D28:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D29:  MOVLW  0A
0D2A:  MOVLB  0F
0D2B:  MOVWF  60
0D2C:  MOVLP  00
0D2D:  MOVLB  00
0D2E:  CALL   01D
0D2F:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D30:  MOVLW  0A
0D31:  MOVLB  0F
0D32:  MOVWF  60
0D33:  MOVLP  00
0D34:  MOVLB  00
0D35:  CALL   01D
0D36:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D37:  MOVLW  0A
0D38:  MOVLB  0F
0D39:  MOVWF  60
0D3A:  MOVLP  00
0D3B:  MOVLB  00
0D3C:  CALL   01D
0D3D:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D3E:  MOVLW  0A
0D3F:  MOVLB  0F
0D40:  MOVWF  60
0D41:  MOVLP  00
0D42:  MOVLB  00
0D43:  CALL   01D
0D44:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D45:  MOVLW  0A
0D46:  MOVLB  0F
0D47:  MOVWF  60
0D48:  MOVLP  00
0D49:  MOVLB  00
0D4A:  CALL   01D
0D4B:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D4C:  MOVLW  0A
0D4D:  MOVLB  0F
0D4E:  MOVWF  60
0D4F:  MOVLP  00
0D50:  MOVLB  00
0D51:  CALL   01D
0D52:  MOVLP  08
....................       //putchar ('+', UBLOX);
....................       for (int16 n = 0; n < 500; n++){ 
0D53:  MOVLB  0F
0D54:  CLRF   46
0D55:  CLRF   45
0D56:  MOVF   46,W
0D57:  SUBLW  01
0D58:  BTFSS  03.0
0D59:  GOTO   57A
0D5A:  BTFSS  03.2
0D5B:  GOTO   560
0D5C:  MOVF   45,W
0D5D:  SUBLW  F3
0D5E:  BTFSS  03.0
0D5F:  GOTO   57A
....................       //buff[i] = getchar (UBLOX);  
....................       C__ = getchar (UBLOX);  
0D60:  MOVLP  00
0D61:  MOVLB  00
0D62:  GOTO   083
0D63:  MOVLP  08
0D64:  MOVF   78,W
0D65:  MOVWF  74
....................       buff[n] = C__;
0D66:  MOVLW  7B
0D67:  MOVLB  0F
0D68:  ADDWF  45,W
0D69:  MOVWF  04
0D6A:  MOVLW  20
0D6B:  ADDWFC 46,W
0D6C:  MOVWF  05
0D6D:  MOVF   74,W
0D6E:  MOVWF  00
....................       putchar(C__,UBLOX);
0D6F:  MOVF   74,W
0D70:  MOVWF  60
0D71:  MOVLP  00
0D72:  MOVLB  00
0D73:  CALL   01D
0D74:  MOVLP  08
0D75:  MOVLB  0F
0D76:  INCF   45,F
0D77:  BTFSC  03.2
0D78:  INCF   46,F
0D79:  GOTO   556
....................       }
....................       //putchar ('*', UBLOX);
....................       delay_ms(10);
0D7A:  MOVLW  0A
0D7B:  MOVWF  51
0D7C:  MOVLP  00
0D7D:  MOVLB  00
0D7E:  CALL   075
0D7F:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D80:  MOVLW  0A
0D81:  MOVLB  0F
0D82:  MOVWF  60
0D83:  MOVLP  00
0D84:  MOVLB  00
0D85:  CALL   01D
0D86:  MOVLP  08
....................       putchar ('@', UBLOX);
0D87:  MOVLW  40
0D88:  MOVLB  0F
0D89:  MOVWF  60
0D8A:  MOVLP  00
0D8B:  MOVLB  00
0D8C:  CALL   01D
0D8D:  MOVLP  08
....................       putchar ('\n', UBLOX);
0D8E:  MOVLW  0A
0D8F:  MOVLB  0F
0D90:  MOVWF  60
0D91:  MOVLP  00
0D92:  MOVLB  00
0D93:  CALL   01D
0D94:  MOVLP  08
....................       //for (INT i = 0; i < 100; i++){       putchar(buff[i],UBLOX);      }
....................       
....................       for (int16 n = 0; n < 500; n++)
0D95:  MOVLB  0F
0D96:  CLRF   48
0D97:  CLRF   47
0D98:  MOVF   48,W
0D99:  SUBLW  01
0D9A:  BTFSS  03.0
0D9B:  GOTO   6C8
0D9C:  BTFSS  03.2
0D9D:  GOTO   5A2
0D9E:  MOVF   47,W
0D9F:  SUBLW  F3
0DA0:  BTFSS  03.0
0DA1:  GOTO   6C8
....................       {
....................          //putchar(buff[n],UBLOX);
....................          newData = encode ( buff[n] );
0DA2:  MOVLW  7B
0DA3:  ADDWF  47,W
0DA4:  MOVWF  04
0DA5:  MOVLW  20
0DA6:  ADDWFC 48,W
0DA7:  MOVWF  05
0DA8:  MOVF   00,W
0DA9:  MOVWF  50
0DAA:  MOVWF  51
0DAB:  MOVLP  00
0DAC:  MOVLB  00
0DAD:  GOTO   6D0
0DAE:  MOVLP  08
0DAF:  BCF    70.2
0DB0:  BTFSC  78.0
0DB1:  BSF    70.2
.................... 
....................          IF (newData)
0DB2:  BTFSS  70.2
0DB3:  GOTO   6C3
....................          {
....................             //putchar ('1', UBLOX);
....................             INT sats = satellites ();
....................             //putchar ('2', UBLOX);
....................             UNSIGNED int32 hdop__ = hdop ();
*
0DB6:  MOVF   78,W
0DB7:  MOVLB  0F
0DB8:  MOVWF  49
*
0DC2:  MOVF   7A,W
0DC3:  MOVLB  0F
0DC4:  MOVWF  4D
0DC5:  MOVF   79,W
0DC6:  MOVWF  4C
0DC7:  MOVF   78,W
0DC8:  MOVWF  4B
0DC9:  MOVF   77,W
0DCA:  MOVWF  4A
....................             f_get_position (&flat,&flon,&age);
0DCB:  MOVLW  24
0DCC:  MOVWF  51
0DCD:  MOVLW  63
0DCE:  MOVWF  50
0DCF:  MOVLW  24
0DD0:  MOVWF  53
0DD1:  MOVLW  67
0DD2:  MOVWF  52
0DD3:  MOVLW  24
0DD4:  MOVWF  55
0DD5:  MOVLW  6B
0DD6:  MOVWF  54
0DD7:  MOVLB  00
0DD8:  GOTO   0CD
....................             //putchar ('3', UBLOX);
....................             IF (flat == GPS_INVALID_F_ANGLE) flat = 0.0;
0DD9:  MOVLB  0E
0DDA:  MOVF   26,W
0DDB:  MOVLB  0F
0DDC:  MOVWF  53
0DDD:  MOVLB  0E
0DDE:  MOVF   25,W
0DDF:  MOVLB  0F
0DE0:  MOVWF  52
0DE1:  MOVLB  0E
0DE2:  MOVF   24,W
0DE3:  MOVLB  0F
0DE4:  MOVWF  51
0DE5:  MOVLB  0E
0DE6:  MOVF   23,W
0DE7:  MOVLB  0F
0DE8:  MOVWF  50
0DE9:  CLRF   57
0DEA:  CLRF   56
0DEB:  MOVLW  7A
0DEC:  MOVWF  55
0DED:  MOVLW  88
0DEE:  MOVWF  54
0DEF:  MOVLP  00
0DF0:  MOVLB  00
0DF1:  CALL   752
0DF2:  MOVLP  08
0DF3:  BTFSS  03.2
0DF4:  GOTO   5FB
0DF5:  MOVLB  0E
0DF6:  CLRF   26
0DF7:  CLRF   25
0DF8:  CLRF   24
0DF9:  CLRF   23
0DFA:  MOVLB  00
....................             IF (flon == GPS_INVALID_F_ANGLE) flon = 0.0;
0DFB:  MOVLB  0E
0DFC:  MOVF   2A,W
0DFD:  MOVLB  0F
0DFE:  MOVWF  53
0DFF:  MOVLB  0E
0E00:  MOVF   29,W
0E01:  MOVLB  0F
0E02:  MOVWF  52
0E03:  MOVLB  0E
0E04:  MOVF   28,W
0E05:  MOVLB  0F
0E06:  MOVWF  51
0E07:  MOVLB  0E
0E08:  MOVF   27,W
0E09:  MOVLB  0F
0E0A:  MOVWF  50
0E0B:  CLRF   57
0E0C:  CLRF   56
0E0D:  MOVLW  7A
0E0E:  MOVWF  55
0E0F:  MOVLW  88
0E10:  MOVWF  54
0E11:  MOVLP  00
0E12:  MOVLB  00
0E13:  CALL   752
0E14:  MOVLP  08
0E15:  BTFSS  03.2
0E16:  GOTO   61D
0E17:  MOVLB  0E
0E18:  CLRF   2A
0E19:  CLRF   29
0E1A:  CLRF   28
0E1B:  CLRF   27
0E1C:  MOVLB  00
....................             IF (satellites () == GPS_INVALID_SATELLITES) sats = 0;
*
0E1F:  INCFSZ 78,W
0E20:  GOTO   624
0E21:  MOVLB  0F
0E22:  CLRF   49
0E23:  MOVLB  00
....................             //putchar ('4', UBLOX);
....................             IF (hdop () == GPS_INVALID_HDOP) hdop__ =  0;
*
0E2C:  MOVF   7A,W
0E2D:  MOVLB  0F
0E2E:  MOVWF  53
0E2F:  MOVF   79,W
0E30:  MOVWF  52
0E31:  MOVF   78,W
0E32:  MOVWF  51
0E33:  MOVF   77,W
0E34:  MOVWF  50
0E35:  INCFSZ 50,W
0E36:  GOTO   641
0E37:  INCFSZ 51,W
0E38:  GOTO   641
0E39:  INCFSZ 52,W
0E3A:  GOTO   641
0E3B:  INCFSZ 53,W
0E3C:  GOTO   641
0E3D:  CLRF   4D
0E3E:  CLRF   4C
0E3F:  CLRF   4B
0E40:  CLRF   4A
....................             fprintf (UBLOX, "La: %.6f Lo: %.6f sat: %d hdop: %ld\r\n", flat, flon, sats, hdop__);
0E41:  MOVLW  0A
0E42:  MOVLB  10
0E43:  MOVWF  1A
0E44:  MOVLW  00
0E45:  MOVWF  1B
0E46:  BCF    03.0
0E47:  MOVLW  04
0E48:  MOVLB  0F
0E49:  MOVWF  50
0E4A:  MOVLP  00
0E4B:  MOVLB  00
0E4C:  CALL   793
0E4D:  MOVLP  08
0E4E:  MOVLW  89
0E4F:  MOVWF  04
0E50:  MOVLB  0E
0E51:  MOVF   26,W
0E52:  MOVLB  0F
0E53:  MOVWF  53
0E54:  MOVLB  0E
0E55:  MOVF   25,W
0E56:  MOVLB  0F
0E57:  MOVWF  52
0E58:  MOVLB  0E
0E59:  MOVF   24,W
0E5A:  MOVLB  0F
0E5B:  MOVWF  51
0E5C:  MOVLB  0E
0E5D:  MOVF   23,W
0E5E:  MOVLB  0F
0E5F:  MOVWF  50
0E60:  MOVLW  06
0E61:  MOVWF  54
0E62:  MOVLB  00
0E63:  CALL   1E1
0E64:  MOVLW  0E
0E65:  MOVLB  10
0E66:  MOVWF  1A
0E67:  MOVLW  00
0E68:  MOVWF  1B
0E69:  BCF    03.0
0E6A:  MOVLW  05
0E6B:  MOVLB  0F
0E6C:  MOVWF  50
0E6D:  MOVLP  00
0E6E:  MOVLB  00
0E6F:  CALL   793
0E70:  MOVLP  08
0E71:  MOVLW  89
0E72:  MOVWF  04
0E73:  MOVLB  0E
0E74:  MOVF   2A,W
0E75:  MOVLB  0F
0E76:  MOVWF  53
0E77:  MOVLB  0E
0E78:  MOVF   29,W
0E79:  MOVLB  0F
0E7A:  MOVWF  52
0E7B:  MOVLB  0E
0E7C:  MOVF   28,W
0E7D:  MOVLB  0F
0E7E:  MOVWF  51
0E7F:  MOVLB  0E
0E80:  MOVF   27,W
0E81:  MOVLB  0F
0E82:  MOVWF  50
0E83:  MOVLW  06
0E84:  MOVWF  54
0E85:  MOVLB  00
0E86:  CALL   1E1
0E87:  MOVLW  12
0E88:  MOVLB  10
0E89:  MOVWF  1A
0E8A:  MOVLW  00
0E8B:  MOVWF  1B
0E8C:  BSF    03.0
0E8D:  MOVLW  06
0E8E:  MOVLB  0F
0E8F:  MOVWF  50
0E90:  MOVLP  00
0E91:  MOVLB  00
0E92:  CALL   793
0E93:  MOVLP  08
0E94:  MOVLB  0F
0E95:  MOVF   49,W
0E96:  MOVWF  50
0E97:  MOVLW  18
0E98:  MOVWF  51
0E99:  MOVLB  00
0E9A:  GOTO   372
0E9B:  MOVLW  16
0E9C:  MOVLB  10
0E9D:  MOVWF  1A
0E9E:  MOVLW  00
0E9F:  MOVWF  1B
0EA0:  BSF    03.0
0EA1:  MOVLW  07
0EA2:  MOVLB  0F
0EA3:  MOVWF  50
0EA4:  MOVLP  00
0EA5:  MOVLB  00
0EA6:  CALL   793
0EA7:  MOVLP  08
0EA8:  MOVLW  41
0EA9:  MOVWF  04
0EAA:  MOVLB  0F
0EAB:  MOVF   4D,W
0EAC:  MOVWF  53
0EAD:  MOVF   4C,W
0EAE:  MOVWF  52
0EAF:  MOVF   4B,W
0EB0:  MOVWF  51
0EB1:  MOVF   4A,W
0EB2:  MOVWF  50
0EB3:  MOVLB  00
0EB4:  GOTO   3DE
0EB5:  MOVLW  0D
0EB6:  MOVLB  0F
0EB7:  MOVWF  60
0EB8:  MOVLP  00
0EB9:  MOVLB  00
0EBA:  CALL   01D
0EBB:  MOVLP  08
0EBC:  MOVLW  0A
0EBD:  MOVLB  0F
0EBE:  MOVWF  60
0EBF:  MOVLP  00
0EC0:  MOVLB  00
0EC1:  CALL   01D
0EC2:  MOVLP  08
....................          }
0EC3:  MOVLB  0F
0EC4:  INCF   47,F
0EC5:  BTFSC  03.2
0EC6:  INCF   48,F
0EC7:  GOTO   598
....................       }
0EC8:  MOVLB  00
0EC9:  GOTO   510
....................    }
.................... }//*/
.................... 
0ECA:  SLEEP
.................... /*
.................... void main()
.................... {
....................    setup_lcd (LCD_DISABLED) ;
....................    //enable_interrupts (INT_RDA) ;
....................    //enable_interrupts (GLOBAL) ;
....................    fprintf (UBLOX, "BOOT ! \r\n\r\n\r\n") ;
....................    
....................    //WHILE (TRUE) { putchar (getchar (UBLOX), UBLOX);  }
....................    
....................    strcpy (a, "\n$GPRMC, 162740.00, A, 1205.07505, S, 07702.82978, W, 3.773, 246.40, 150221,,, A * 69\n\0"); decodeString ();
....................    //strcpy (a, "$GPGSV, 4, 1, 15, 01, 18, 225, 34, 03, 32, 290, 41, 04, 11, 339, 25, 08, 57, 198, 25 * 79\n\0"); decodeString ();
....................    strcpy (a, "$GPRMC,,V,,,,,,,,,,N*53\n\0"); decodeString ();
....................    strcpy (a, "$GPGGA, 162740.00, 1205.07505, S, 07702.82978, W, 1, 05, 4.87, 44.5, M, 9.0, M,, * 58\n\0"); decodeString ();
....................    
....................    //strcpy (a, "$GPGSV, 4, 1, 15, 01, 18, 225, 34, 03, 32, 290, 41, 04, 11, 339, 25, 08, 57, 198, 25 * 79\n\0"); decodeString ();
....................    //newData = true;
.................... 
....................    IF (newData)
....................    {
....................       INT sats = satellites ();
....................       UNSIGNED int32 hdop__ = hdop ();
....................       f_get_position (&flat,&flon,&age);
....................       //IF (flat != GPS_INVALID_F_ANGLE) flat = 0.0;//, 6; /////////////////////////////////////////////////////////////////////////////////////
....................       //IF (flon != GPS_INVALID_F_ANGLE) flon = 0.0;//, 6; ////////////////////////////////////////////////////////////////////////////////////
....................       IF (satellites () == GPS_INVALID_SATELLITES) sats = 0;
....................       IF (hdop () == GPS_INVALID_HDOP) hdop__ =  0;
....................       fprintf (UBLOX, "La: %.6f Lo: %.6f sat: %d hdop: %ld\r\n\r\n\r\n", flat, flon, sats, hdop__);
....................    }
.................... 
....................    WHILE (TRUE)
....................    {
....................       putchar ('*', UBLOX);
....................       //getchar (UBLOX) ;
....................       //getch (UBLOX) ;
....................       //getc (UBLOX) ;
....................       //putchar (' + ', UBLOX);
....................       //encode (getchar (UBLOX) );
....................       //putchar (' - ', UBLOX);
....................       IF (encode  (getchar (UBLOX) ) == true){putchar ('~', UBLOX); }
....................       ELSE{putchar ('!', UBLOX); }
....................       putchar ('@', UBLOX);
.................... 
....................       //IF (kbhit (UBLOX))
....................       {
....................          IF (encode (getchar (UBLOX) ) )
....................          {
....................             putchar ('1', UBLOX);
....................             INT sats = satellites ();
....................             putchar ('2', UBLOX);
....................             UNSIGNED int32 hdop__ = hdop ();
....................             f_get_position (&flat,&flon,&age);
....................             putchar ('3', UBLOX);
....................             IF (flat != GPS_INVALID_F_ANGLE) flat = 0.0;
....................             IF (flon != GPS_INVALID_F_ANGLE) flon = 0.0;
....................             IF (satellites () == GPS_INVALID_SATELLITES) sats = 0;
....................             putchar ('4', UBLOX);
....................             IF (hdop () == GPS_INVALID_HDOP) hdop__ =  0;
....................             fprintf (UBLOX, "La: %.6f Lo: %.6f sat: %d hdop: %ld\r\n\r\n\r\n", flat, flon, sats, hdop__);
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //*/
.................... 
.................... 

Configuration Fuses:
   Word  1: 3BE8   NOEXTOSC RSTOSC_HFINTRC NOCLKOUT NOVBATEN NOLCDPEN CKS FCMEN
   Word  2: 3B3D   MCLR PUT_64MS NOLPBOR NOBROWNOUT BORV24 NOZCDDIS PPS1WAY STVREN NODEBUG
   Word  3: 3F9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: 3FFF   BBSIZ512 NOBOOTBLOCK NOSAF NOWRT NOWRTB NOWRTC NOWRTD NOWRTSAF LVP
   Word  5: 3FFF   NOPROTECT
